import asyncio
import discord # type: ignore
from discord.ext import commands # type: ignore
from discord import app_commands # type: ignore
import yt_dlp # type: ignore
import os
import re
import random
from collections import deque
import logging
from utils.channel_manager import ChannelManager

# Suppress noise about console usage from errors
def _suppress_bug_reports(*args, **kwargs):
    return ''

yt_dlp.utils.bug_reports_message = _suppress_bug_reports

# YouTube music bot v·ªõi yt-dlp
ytdl_format_options = {
    'format': 'bestaudio/best',
    'noplaylist': False,  # Cho ph√©p playlist
    'quiet': True,
    'no_warnings': True,
    'default_search': 'auto',
    'source_address': '0.0.0.0',
    'ignoreerrors': True,  # B·ªè qua l·ªói trong playlist
    'restrictfilenames': True,
    'nocheckcertificate': True,
    'outtmpl': '%(extractor)s-%(id)s-%(title)s.%(ext)s',
    'logtostderr': False,
    'age_limit': 18,
    'extract_flat': False,
    'playlistend': 50,  # Gi·ªõi h·∫°n 50 b√†i ƒë·ªÉ tr√°nh spam
    'http_headers': {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36'
    }
}

# FFmpeg options - improved for stability
ffmpeg_options = {
    'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
    'options': '-vn -filter:a "volume=0.5"'
}

ytdl = yt_dlp.YoutubeDL(ytdl_format_options)


class YTDLSource(discord.PCMVolumeTransformer):
    def __init__(self, source, *, data, volume=0.5):
        super().__init__(source, volume)
        self.data = data
        self.title = data.get('title')
        self.url = data.get('url')
        self.duration = data.get('duration')
        self.uploader = data.get('uploader')
        self.thumbnail = data.get('thumbnail')

    @classmethod
    async def from_url(cls, url, *, loop=None, stream=False):
        print(f"üîß YTDLSource.from_url called")
        print(f"üîó URL: {url[:50]}...")
        print(f"üì° Stream: {stream}")
        
        loop = loop or asyncio.get_event_loop()
        
        def extract_info():
            print(f"üì¶ Extracting info from yt-dlp...")
            try:
                result = ytdl.extract_info(url, download=not stream)
                print(f"‚úÖ Info extracted successfully")
                return result
            except Exception as e:
                print(f"‚ùå Error extracting info: {e}")
                raise
            
        try:
            data = await loop.run_in_executor(None, extract_info)
            if 'entries' in data:
                data = data['entries'][0]
            
            filename = data['url'] if stream else ytdl.prepare_filename(data)
            print(f"üéµ Audio filename/URL: {filename[:50]}...")
            
            # Use the improved FFmpeg options
            print(f"üîä Creating FFmpegPCMAudio...")
            audio_source = discord.FFmpegPCMAudio(
                filename, 
                before_options=ffmpeg_options['before_options'],
                options=ffmpeg_options['options']
            )
            print(f"‚úÖ FFmpegPCMAudio created successfully")
            
            player = cls(audio_source, data=data)
            print(f"üéµ YTDLSource player created - Title: {player.title}")
            return player
            
        except Exception as e:
            print(f"‚ùå YTDLSource.from_url failed: {e}")
            print(f"üîç Error type: {type(e).__name__}")
            raise

    @classmethod
    async def search_youtube(cls, search_term, *, loop=None):
        loop = loop or asyncio.get_event_loop()
        try:
            def search_func():
                print(f"üîç Searching YouTube for: {search_term}")
                return ytdl.extract_info(f"ytsearch:{search_term}", download=False)
            
            data = await loop.run_in_executor(None, search_func)
            if 'entries' in data and len(data['entries']) > 0:
                result = data['entries'][0]
                print(f"‚úÖ Found: {result.get('title', 'Unknown title')}")
                return result
            else:
                print(f"‚ùå No results found for: {search_term}")
        except yt_dlp.utils.DownloadError as e:
            print(f"‚ùå YouTube download error: {e}")
            if "403" in str(e):
                print("‚ö†Ô∏è YouTube 403 error - may need to update yt-dlp")
        except Exception as e:
            print(f"‚ùå YouTube search error: {e}")
        return None




class MusicQueue:
    def __init__(self):
        self.queue = deque()
        self.current = None
        self.loop_song = False
        self.loop_queue = False
        self.loop_mode = "off"  # "off", "song", "queue"
        self.auto_dj = False
        self.auto_dj_24_7 = False  # 24/7 mode
        self.history = []  # Store played songs
        self.playlists = {}  # user_id: {playlist_name: [songs]}
        self.preferred_genres = [
            "nh·∫°c vi·ªát nam", "vpop", "ballad vi·ªát", "rap vi·ªát", "indie vi·ªát",
            "nh·∫°c lofi vi·ªát", "acoustic vi·ªát", "nh·∫°c tr·∫ª vi·ªát nam"
        ]  # ∆Øu ti√™n nh·∫°c Vi·ªát cho Auto DJ
        
        # State tracking
        self.is_paused = False

    def add(self, song):
        self.queue.append(song)

    def get_next(self):
        # Add current song to history if exists
        if self.current:
            self.history.append(self.current)
            # Keep only last 50 songs in history
            if len(self.history) > 50:
                self.history.pop(0)
        
        # Handle loop modes
        if self.loop_mode == "song" and self.current:
            return self.current
        
        if len(self.queue) > 0:
            song = self.queue.popleft()
            
            # If loop queue mode, add song back to end
            if self.loop_mode == "queue":
                self.queue.append(song)
            
            return song
        
        # Auto DJ 24/7 - return None to trigger auto search
        if self.auto_dj_24_7:
            return None
            
        return None

    def clear(self):
        self.queue.clear()
        self.current = None

    def skip(self):
        if len(self.queue) > 0:
            return self.queue.popleft()
        return None

    def shuffle(self):
        import random
        queue_list = list(self.queue)
        random.shuffle(queue_list)
        self.queue = deque(queue_list)
        
    def save_playlist(self, user_id, playlist_name, songs):
        """L∆∞u playlist c·ªßa user"""
        if user_id not in self.playlists:
            self.playlists[user_id] = {}
        self.playlists[user_id][playlist_name] = songs
        
    def get_playlist(self, user_id, playlist_name):
        """L·∫•y playlist c·ªßa user"""
        return self.playlists.get(user_id, {}).get(playlist_name, [])
        
    def list_playlists(self, user_id):
        """Li·ªát k√™ playlist c·ªßa user"""
        return list(self.playlists.get(user_id, {}).keys())
        
    def delete_playlist(self, user_id, playlist_name):
        """X√≥a playlist"""
        if user_id in self.playlists and playlist_name in self.playlists[user_id]:
            del self.playlists[user_id][playlist_name]
            return True
        return False


class MusicControlView(discord.ui.View):
    """Music control panel for current playing song"""
    
    def __init__(self, bot, guild_id):
        super().__init__(timeout=300)  # 5 minutes timeout
        self.bot = bot
        self.guild_id = guild_id
        self.message = None  # Store the message for editing
    
    @discord.ui.button(emoji='‚è∏Ô∏è', style=discord.ButtonStyle.secondary)
    async def pause_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        guild = self.bot.get_guild(self.guild_id)
        if guild and guild.voice_client and guild.voice_client.is_playing():
            guild.voice_client.pause()
            await interaction.response.send_message("‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng nh·∫°c!", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Kh√¥ng c√≥ nh·∫°c ƒëang ph√°t!", ephemeral=True)
    
    @discord.ui.button(emoji='‚ñ∂Ô∏è', style=discord.ButtonStyle.secondary)
    async def resume_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        guild = self.bot.get_guild(self.guild_id)
        if guild and guild.voice_client and guild.voice_client.is_paused():
            guild.voice_client.resume()
            await interaction.response.send_message("‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c!", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Nh·∫°c kh√¥ng b·ªã t·∫°m d·ª´ng!", ephemeral=True)
    
    @discord.ui.button(emoji='‚è≠Ô∏è', style=discord.ButtonStyle.secondary)
    async def skip_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        guild = self.bot.get_guild(self.guild_id)
        if guild and guild.voice_client and guild.voice_client.is_playing():
            guild.voice_client.stop()
            await interaction.response.send_message("‚è≠Ô∏è ƒê√£ b·ªè qua b√†i h√°t!", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Kh√¥ng c√≥ nh·∫°c ƒëang ph√°t!", ephemeral=True)
    
    @discord.ui.button(emoji='‚èπÔ∏è', style=discord.ButtonStyle.danger)
    async def stop_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        music_cog = self.bot.get_cog('MusicCog')
        if music_cog:
            queue = music_cog.get_queue(self.guild_id)
            queue.clear()
            
            guild = self.bot.get_guild(self.guild_id)
            if guild and guild.voice_client:
                if guild.voice_client.is_playing():
                    guild.voice_client.stop()
                await guild.voice_client.disconnect()
                await interaction.response.send_message("‚èπÔ∏è ƒê√£ d·ª´ng nh·∫°c v√† r·ªùi kh·ªèi voice channel!", ephemeral=True)
            else:
                await interaction.response.send_message("‚ùå Bot kh√¥ng ·ªü trong voice channel!", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Music module kh√¥ng kh·∫£ d·ª•ng!", ephemeral=True)
    
    @discord.ui.button(emoji='üîÄ', style=discord.ButtonStyle.secondary, row=1)
    async def shuffle_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        music_cog = self.bot.get_cog('MusicCog')
        if music_cog:
            queue = music_cog.get_queue(self.guild_id)
            if len(queue.queue) > 1:
                queue.shuffle()
                await interaction.response.send_message("üîÄ ƒê√£ x√°o tr·ªôn queue!", ephemeral=True)
            else:
                await interaction.response.send_message("‚ùå C·∫ßn √≠t nh·∫•t 2 b√†i h√°t trong queue ƒë·ªÉ x√°o tr·ªôn!", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Music module kh√¥ng kh·∫£ d·ª•ng!", ephemeral=True)
    
    @discord.ui.button(emoji='üîÅ', style=discord.ButtonStyle.secondary, row=1)
    async def loop_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        music_cog = self.bot.get_cog('MusicCog')
        if music_cog:
            queue = music_cog.get_queue(self.guild_id)
            # Cycle through loop modes: off -> song -> queue -> off
            if queue.loop_mode == "off":
                queue.loop_mode = "song"
                queue.loop_song = True
                queue.loop_queue = False
                await interaction.response.send_message("üîÅ ƒê·∫∑t ch·∫ø ƒë·ªô l·∫∑p b√†i h√°t!", ephemeral=True)
            elif queue.loop_mode == "song":
                queue.loop_mode = "queue"
                queue.loop_song = False
                queue.loop_queue = True
                await interaction.response.send_message("üîÅ ƒê·∫∑t ch·∫ø ƒë·ªô l·∫∑p queue!", ephemeral=True)
            else:
                queue.loop_mode = "off"
                queue.loop_song = False
                queue.loop_queue = False
                await interaction.response.send_message("üîÅ T·∫Øt ch·∫ø ƒë·ªô l·∫∑p!", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Music module kh√¥ng kh·∫£ d·ª•ng!", ephemeral=True)
    
    @discord.ui.button(emoji='üìù', style=discord.ButtonStyle.secondary, row=1)
    async def queue_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        music_cog = self.bot.get_cog('MusicCog')
        if music_cog:
            queue = music_cog.get_queue(self.guild_id)
            
            if not queue.queue and not queue.current:
                await interaction.response.send_message("üìù Queue tr·ªëng!", ephemeral=True)
                return

            embed = discord.Embed(title="üéµ Music Queue", color=0x0099ff)
            
            if queue.current:
                embed.add_field(
                    name="üéµ ƒêang ph√°t",
                    value=f"**{queue.current['title']}**",
                    inline=False
                )

            if queue.queue:
                queue_list = []
                for i, song in enumerate(list(queue.queue)[:10], 1):
                    queue_list.append(f"**{i}.** {song['title']}")
                
                embed.add_field(
                    name="üìù Ti·∫øp theo",
                    value="\n".join(queue_list),
                    inline=False
                )
                
                if len(queue.queue) > 10:
                    embed.add_field(
                        name="‚ûï V√† h∆°n n·ªØa",
                        value=f"**{len(queue.queue) - 10}** b√†i h√°t kh√°c...",
                        inline=False
                    )

            await interaction.response.send_message(embed=embed, ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Music module kh√¥ng kh·∫£ d·ª•ng!", ephemeral=True)
    
    @discord.ui.button(emoji='üîä', style=discord.ButtonStyle.secondary, row=1)
    async def volume_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        guild = self.bot.get_guild(self.guild_id)
        if guild and guild.voice_client:
            if hasattr(guild.voice_client.source, 'volume'):
                current_volume = int(guild.voice_client.source.volume * 100)
                await interaction.response.send_message(f"üîä √Çm l∆∞·ª£ng hi·ªán t·∫°i: **{current_volume}%**\nD√πng `!volume <0-100>` ƒë·ªÉ thay ƒë·ªïi", ephemeral=True)
            else:
                await interaction.response.send_message("‚ùå Kh√¥ng th·ªÉ xem √¢m l∆∞·ª£ng v·ªõi ngu·ªìn √¢m thanh hi·ªán t·∫°i!", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Bot kh√¥ng ·ªü trong voice channel!", ephemeral=True)
    
    @discord.ui.button(emoji='üéµ', style=discord.ButtonStyle.primary, row=1)
    async def add_song_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message("üéµ **Th√™m b√†i h√°t:**\nD√πng l·ªánh `!play <t√™n b√†i h√°t>` ho·∫∑c `/play` ƒë·ªÉ th√™m nh·∫°c v√†o queue!", ephemeral=True)
    
    async def on_timeout(self):
        # Disable all buttons when view times out
        for item in self.children:
            item.disabled = True
        
        if self.message:
            try:
                await self.message.edit(view=self)
            except:
                pass
        # Disable all buttons when timeout
        for item in self.children:
            item.disabled = True
        
        try:
            # Try to edit the message to show it's expired
            if hasattr(self, 'message') and self.message:
                embed = discord.Embed(
                    title="‚è∞ B·ªô ƒëi·ªÅu khi·ªÉn ƒë√£ h·∫øt h·∫°n",
                    description="G√µ `!controls` ƒë·ªÉ t·∫°o b·ªô ƒëi·ªÅu khi·ªÉn m·ªõi",
                    color=discord.Color.red()
                )
                await self.message.edit(embed=embed, view=self)
        except:
            pass


class VolumeModal(discord.ui.Modal, title='üîä ƒêi·ªÅu ch·ªânh √¢m l∆∞·ª£ng'):
    volume = discord.ui.TextInput(
        label='√Çm l∆∞·ª£ng (0-100)',
        placeholder='Nh·∫≠p √¢m l∆∞·ª£ng t·ª´ 0 ƒë·∫øn 100...',
        style=discord.TextStyle.short,
        max_length=3
    )
    
    async def on_submit(self, interaction: discord.Interaction):
        try:
            vol = int(self.volume.value)
            if vol < 0 or vol > 100:
                await interaction.response.send_message("‚ùå √Çm l∆∞·ª£ng ph·∫£i t·ª´ 0 ƒë·∫øn 100!", ephemeral=True)
                return
            
            # Direct implementation instead of calling non-existent method
            guild = interaction.guild
            if guild and guild.voice_client:
                if hasattr(guild.voice_client.source, 'volume'):
                    guild.voice_client.source.volume = vol / 100
                    await interaction.response.send_message(f"üîä ƒê√£ ƒë·∫∑t √¢m l∆∞·ª£ng th√†nh **{vol}%**", ephemeral=True)
                else:
                    await interaction.response.send_message("‚ùå Kh√¥ng th·ªÉ thay ƒë·ªïi √¢m l∆∞·ª£ng v·ªõi ngu·ªìn √¢m thanh hi·ªán t·∫°i!", ephemeral=True)
            else:
                await interaction.response.send_message("‚ùå Bot kh√¥ng ·ªü trong voice channel!", ephemeral=True)
        except ValueError:
            await interaction.response.send_message("‚ùå Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá!", ephemeral=True)


class MusicCog(commands.Cog):
    """Music commands for YouTube"""

    def __init__(self, bot):
        self.bot = bot
        self.music_queues = {}  # Guild ID -> MusicQueue
        # Per-guild HQ config
        self.hq_settings = {}  # guild_id -> {'normalize': bool}

    def get_queue(self, guild_id):
        if guild_id not in self.music_queues:
            self.music_queues[guild_id] = MusicQueue()
        return self.music_queues[guild_id]
    
    def format_duration(self, duration):
        """Format duration from seconds to MM:SS"""
        if not duration:
            return "N/A"
        try:
            duration = int(float(duration))
            minutes = duration // 60
            seconds = duration % 60
            return f"{minutes}:{seconds:02d}"
        except (ValueError, TypeError):
            return "N/A"
    
    def create_fake_context(self, interaction):
        """Create a fake context object for interaction compatibility"""
        class FakeContext:
            def __init__(self, interaction):
                self.guild = interaction.guild
                self.voice_client = interaction.guild.voice_client
                self.author = interaction.user
                self.channel = interaction.channel
                self.bot = interaction.client
                
            async def send(self, content=None, **kwargs):
                # Try to send as followup if possible
                try:
                    if hasattr(interaction, 'followup'):
                        return await interaction.followup.send(content, **kwargs)
                    else:
                        return await interaction.response.send_message(content, **kwargs)
                except:
                    # Fallback to channel send
                    return await self.channel.send(content, **kwargs)
        
        return FakeContext(interaction)

    def build_ffmpeg_args(self, guild_id: int):
        """Build FFmpeg arguments for YouTube streaming"""
        cfg = self.hq_settings.get(guild_id, {'normalize': False})
        
        # YouTube v·ªõi ch·∫•t l∆∞·ª£ng cao h∆°n v√† reconnect
        opts = "-vn -ar 48000 -ac 2 -loglevel quiet"
        before_opts = ffmpeg_options['before_options']
        print(f"üîß Applying YouTube optimized config")
        
        # Th√™m loudness normalization n·∫øu ƒë∆∞·ª£c b·∫≠t
        if cfg.get('normalize'):
            opts += " -af loudnorm=I=-14:LRA=11:TP=-1.5"
            print(f"üéöÔ∏è Added loudness normalization for YouTube")
            
        return before_opts, opts

    def is_ffmpeg_expected_error(self, error_str: str) -> bool:
        """Check if FFmpeg error is expected and can be safely ignored"""
        expected_codes = [
            "1",           # Generic exit code 1
            "255",         # FFmpeg termination
            "Connection reset by peer",  # Network issues
            "Server returned 4XX",       # HTTP errors
            "Server returned 5XX",       # Server errors
        ]
        
        error_lower = str(error_str).lower()
        for code in expected_codes:
            if code.lower() in error_lower:
                return True
        return False

    async def create_player(self, data, guild_id: int):
        try:
            webpage_url = data.get('webpage_url', '')
            extractor = data.get('extractor', '')
            
            print(f"üéµ Creating player for: {data.get('title', 'Unknown')}")
            print(f"üîó URL: {webpage_url}")
            print(f"üé¨ Platform: {extractor}")
            
            # S·ª≠ d·ª•ng YouTube player cho t·∫•t c·∫£ content
            print(f"üé¨ Using YouTube optimized player")
            return await self._create_youtube_player(data, guild_id)
                
        except Exception as e:
            print(f"‚ùå Error creating player: {e}")
            raise Exception(f"L·ªói ph√°t nh·∫°c: {e}")

    async def _create_youtube_player(self, data, guild_id: int):
        """T·∫°o player cho YouTube v·ªõi c·∫•u h√¨nh t·ªëi ∆∞u"""
        try:
            print(f"üé¨ Using YouTube optimized approach")
            
            before_opts, ffmpeg_opts = self.build_ffmpeg_args(guild_id)
            print(f"üîß FFmpeg options: {ffmpeg_opts}")
            print(f"üîß FFmpeg before_opts: {before_opts}")
            
            # Debug: Log data structure
            print(f"üìä YouTube data keys: {list(data.keys())}")
            
            # YouTube th√¥ng th∆∞·ªùng v·ªõi c·∫•u h√¨nh t·ªëi ∆∞u
            player = await YTDLSource.from_url(
                data.get('webpage_url', ''), 
                loop=self.bot.loop, 
                stream=True
            )
            
            # Debug: Check player properties
            print(f"üéµ Player created - Title: {getattr(player, 'title', 'No title')}")
            print(f"üîä Player volume: {getattr(player, 'volume', 'No volume')}")
            print(f"‚úÖ YouTube player created successfully!")
            return player
            
        except Exception as e:
            print(f"‚ùå YouTube player creation failed: {e}")
            print(f"üîç Error details: {type(e).__name__}: {str(e)}")
            raise Exception(f"L·ªói ph√°t YouTube: {e}")
        
    

    async def get_auto_dj_song(self, guild_id: int):
        """T√¨m b√†i h√°t ng·∫´u nhi√™n cho Auto DJ 24/7 - ∆∞u ti√™n nh·∫°c Vi·ªát"""
        queue = self.get_queue(guild_id)
        
        # Danh s√°ch t·ª´ kh√≥a t√¨m ki·∫øm nh·∫°c Vi·ªát ∆∞u ti√™n - t·∫≠p trung v√†o MV
        vietnamese_terms = [
            "s∆°n t√πng mtp mv", "ƒëen v√¢u mv", "b√≠ch ph∆∞∆°ng mv", "erik mv", "jack mv", "k-icm mv",
            "ho√†ng th√πy linh mv", "amee mv", "min mv", "ƒë·ª©c ph√∫c mv", "justatee mv", "rhymastic mv",
            "hi·ªÅn h·ªì mv", "cara mv", "orange mv", "v≈© mv", "binz mv", "karik mv", "suboi mv",
            "vpop mv 2024", "nh·∫°c tr·∫ª vi·ªát nam mv", "ballad vi·ªát nam mv", "rap vi·ªát nam mv",
            "indie vi·ªát nam mv", "acoustic vi·ªát nam mv", "viral vi·ªát mv", "trending vpop mv"
        ]
        
        # T·ª´ kh√≥a chung backup - t·∫≠p trung v√†o MV
        general_terms = [
            "pop mv 2024", "trending mv", "viral mv", "acoustic mv", "indie pop mv",
            "chill mv", "lofi mv", "electronic mv", "dance mv", "ballad mv"
        ]
        
        # Ph√¢n t√≠ch b√†i h√°t cu·ªëi ƒë·ªÉ t√¨m nh·∫°c li√™n quan
        if queue.history:
            last_song = queue.history[-1]
            title = last_song.get('title', '').lower()
            uploader = last_song.get('uploader', '').lower()
            
            # Detect Vietnamese content
            vietnamese_indicators = [
                'vi·ªát', 'viet', 'vietnam', 'vpop', 'vrap', 's∆°n t√πng', 'ƒëen v√¢u',
                'b√≠ch ph∆∞∆°ng', 'erik', 'jack', 'amee', 'min', 'hi·ªÅn h·ªì', 'binz',
                'karik', 'rhymastic', 'justatee', 'suboi', 'orange', 'v≈©', 'cara'
            ]
            
            is_vietnamese = any(indicator in title or indicator in uploader 
                              for indicator in vietnamese_indicators)
            
            # T·∫°o t·ª´ kh√≥a th√¥ng minh
            smart_terms = []
            
            if is_vietnamese:
                # N·∫øu b√†i cu·ªëi l√† nh·∫°c Vi·ªát, ∆∞u ti√™n t√¨m nh·∫°c Vi·ªát li√™n quan
                if 's∆°n t√πng' in title or 's∆°n t√πng' in uploader:
                    smart_terms.extend(['s∆°n t√πng mtp mv', 'vpop ballad mv', 'nh·∫°c tr·∫ª vi·ªát mv'])
                elif 'ƒëen' in title or 'ƒëen' in uploader:
                    smart_terms.extend(['ƒëen v√¢u mv', 'rap vi·ªát nam mv', 'underground vi·ªát mv'])
                elif 'erik' in title or 'erik' in uploader:
                    smart_terms.extend(['erik mv', 'vpop 2024 mv', 'nh·∫°c tr·∫ª hay mv'])
                elif 'jack' in title or 'jack' in uploader:
                    smart_terms.extend(['jack mv', 'k-icm mv', 'vpop trending mv'])
                elif 'b√≠ch ph∆∞∆°ng' in title or 'b√≠ch ph∆∞∆°ng' in uploader:
                    smart_terms.extend(['b√≠ch ph∆∞∆°ng mv', 'vpop n·ªØ mv', 'ballad vi·ªát mv'])
                elif 'amee' in title or 'amee' in uploader:
                    smart_terms.extend(['amee mv', 'min mv', 'vpop girl mv'])
                else:
                    # Extract artist name for Vietnamese music
                    artist_parts = uploader.split(' - ')[0].split('Official')[0].strip()
                    if len(artist_parts) > 2:
                        smart_terms.append(f"{artist_parts} mv")
                        smart_terms.append(f"{artist_parts} official mv")
                
                # Th√™m c√°c t·ª´ kh√≥a Vi·ªát t·ªïng qu√°t
                smart_terms.extend(vietnamese_terms[:8])  # Top 8 Vietnamese terms
            else:
                # N·∫øu b√†i cu·ªëi l√† nh·∫°c n∆∞·ªõc ngo√†i, v·∫´n ∆∞u ti√™n nh·∫°c Vi·ªát nh∆∞ng th√™m ch√∫t ƒëa d·∫°ng
                smart_terms.extend(vietnamese_terms[:5])  # Top 5 Vietnamese terms
                
                # Extract artist for international songs
                artist_parts = uploader.split(' - ')[0].split('Official')[0].split('VEVO')[0].strip()
                if len(artist_parts) > 2 and len(artist_parts) < 30:
                    smart_terms.append(f"{artist_parts} mv")
                
                smart_terms.extend(general_terms[:3])  # Add some general terms
        else:
            # Kh√¥ng c√≥ l·ªãch s·ª≠, b·∫Øt ƒë·∫ßu v·ªõi nh·∫°c Vi·ªát
            smart_terms = vietnamese_terms[:10]
        
        # Th·ª≠ t√¨m ki·∫øm v·ªõi t·ª´ kh√≥a th√¥ng minh
        import random
        random.shuffle(smart_terms)  # Tr·ªôn ƒë·ªÉ ƒëa d·∫°ng
        
        for attempt in range(5):  # Th·ª≠ t·ªëi ƒëa 5 l·∫ßn
            try:
                search_term = smart_terms[attempt % len(smart_terms)]
                data = await YTDLSource.search_youtube(search_term)
                
                if data:
                    # Ki·ªÉm tra kh√¥ng ph·∫£i b√†i ƒë√£ ph√°t g·∫ßn ƒë√¢y
                    recent_urls = [song.get('webpage_url', '') for song in queue.history[-15:]]
                    if data.get('webpage_url') not in recent_urls:
                        return data
                        
            except Exception as e:
                print(f"Auto DJ search error for '{search_term}': {e}")
                continue
        
        # Fallback - t√¨m nh·∫°c Vi·ªát c∆° b·∫£n
        try:
            fallback_terms = ["vpop mv 2024", "nh·∫°c vi·ªát mv", "trending vpop mv"]
            data = await YTDLSource.search_youtube(random.choice(fallback_terms))
            return data
        except:
            # Ultimate fallback
            try:
                return await YTDLSource.search_youtube("vietnam mv")
            except:
                return None

    async def play_next(self, ctx):
        """Play the next song in queue"""
        queue = self.get_queue(ctx.guild.id)
        next_song = queue.get_next()
        
        # Auto DJ 24/7 mode - t√¨m b√†i m·ªõi khi h·∫øt queue
        if next_song is None and queue.auto_dj_24_7:
            try:
                print("üîÑ Auto DJ trying to find next song...")
                auto_song = await self.get_auto_dj_song(ctx.guild.id)
                if auto_song:
                    next_song = auto_song
                    # Th√¥ng b√°o Auto DJ
                    try:
                        platform_info = "üé¨ YouTube"
                        
                        embed = discord.Embed(
                            title="üéµ Auto DJ 24/7",
                            description=f"Ph√°t nh·∫°c t·ª± ƒë·ªông: **{auto_song['title']}**",
                            color=discord.Color.purple()
                        )
                        embed.add_field(name="N·ªÅn t·∫£ng", value=platform_info, inline=True)
                        embed.set_footer(text="G√µ !autodj off ƒë·ªÉ t·∫Øt ch·∫ø ƒë·ªô t·ª± ƒë·ªông")
                        await ctx.send(embed=embed)
                    except:
                        pass
            except Exception as e:
                print(f"‚ùå Auto DJ error: {e}")
                # Ng·ª´ng Auto DJ t·∫°m th·ªùi ƒë·ªÉ tr√°nh l·∫∑p l·ªói
                queue.auto_dj_24_7 = False
                try:
                    await ctx.send("‚ö†Ô∏è Auto DJ g·∫∑p l·ªói v√† ƒë√£ ƒë∆∞·ª£c t·∫Øt t·∫°m th·ªùi. G√µ `!autodj on` ƒë·ªÉ b·∫≠t l·∫°i.")
                except:
                    pass
        
        if next_song:
            try:
                # Ensure bot is connected to voice
                if not ctx.voice_client:
                    await ctx.send("‚ùå Bot kh√¥ng c√≤n trong voice channel!")
                    return
                
                if not ctx.voice_client.is_connected():
                    await ctx.send("‚ùå M·∫•t k·∫øt n·ªëi voice channel!")
                    return
                
                player = await self.create_player(next_song, ctx.guild.id)
                queue.current = next_song
                
                def after_playing(error):
                    if error:
                        print(f"‚ùå Player error in play_next: {error}")
                        
                        # Use smart error checking
                        if self.is_ffmpeg_expected_error(str(error)):
                            print(f"‚úÖ Expected FFmpeg error in play_next - continuing")
                        else:
                            print(f"‚ö†Ô∏è Unexpected error in play_next: {error}")
                    else:
                        print(f"‚úÖ Song from play_next finished normally")
                    
                    # Continue to next song if voice client is connected
                    if ctx.guild.voice_client and ctx.guild.voice_client.is_connected():
                        try:
                            coro = self.play_next(ctx)
                            asyncio.run_coroutine_threadsafe(coro, self.bot.loop)
                        except Exception as e:
                            print(f"‚ùå Error in play_next recursion: {e}")
                
                ctx.voice_client.play(player, after=after_playing)
                
                # Update Music Manager state
                if hasattr(self.bot, 'music_manager'):
                    from .music_manager import MusicSource
                    self.bot.music_manager.set_guild_state(
                        ctx.guild.id,
                        MusicSource.YOUTUBE,
                        track_info={
                            'title': player.title,
                            'uploader': player.data.get('uploader', 'Unknown'),
                            'url': player.data.get('url', '')
                        },
                        is_playing=True,
                        queue_size=len(queue.queue)
                    )
                
                    # Ch·ªâ hi·ªÉn th·ªã embed chi ti·∫øt cho nh·∫°c th∆∞·ªùng, kh√¥ng ph·∫£i Auto DJ
                if not queue.auto_dj_24_7 or len(queue.queue) > 0:
                    # Detect platform ƒë·ªÉ hi·ªÉn th·ªã icon ƒë√∫ng
                    platform_info = "üé¨ YouTube"
                    
                    embed = discord.Embed(
                        title="üéµ ƒêang ph√°t",
                        description=f"**{player.title}**",
                        color=0x00ff00
                    )
                    embed.add_field(name="N·ªÅn t·∫£ng", value=platform_info, inline=True)
                    if player.uploader:
                        embed.add_field(name="K√™nh", value=player.uploader, inline=True)
                    if next_song.get('duration'):
                        duration_str = self.format_duration(next_song['duration'])
                        embed.add_field(name="Th·ªùi l∆∞·ª£ng", value=duration_str, inline=True)
                    if player.thumbnail:
                        embed.set_thumbnail(url=player.thumbnail)
                    
                    # G·ªôp b·ªô ƒëi·ªÅu khi·ªÉn v√†o message "ƒêang ph√°t"
                    view = MusicControlView(self.bot, ctx.guild.id)
                    message = await ctx.send(embed=embed, view=view)
                    
                    # L∆∞u message ƒë·ªÉ c√≥ th·ªÉ edit khi timeout
                    view.message = message
                    
                    # ƒêƒÉng k√Ω message ƒë·ªÉ auto cleanup sau 10 ph√∫t
                    auto_cleanup_cog = self.bot.get_cog('AutoCleanupCog')
                    if auto_cleanup_cog:
                        auto_cleanup_cog.add_message_for_cleanup(message, delete_after=600)  # 10 ph√∫t
            except Exception as e:
                print(f"‚ùå Error in play_next: {e}")
                await ctx.send(f"‚ùå L·ªói khi ph√°t nh·∫°c: {e}")
                
                # N·∫øu l√† Auto DJ v√† g·∫∑p l·ªói, t·∫Øt t·∫°m th·ªùi
                if queue.auto_dj_24_7:
                    queue.auto_dj_24_7 = False
                    await ctx.send("‚ö†Ô∏è Auto DJ g·∫∑p l·ªói li√™n t·ª•c v√† ƒë√£ ƒë∆∞·ª£c t·∫Øt. H√£y ki·ªÉm tra l·∫°i sau.")
        else:
            queue.current = None
            if not queue.auto_dj_24_7:
                await ctx.send("‚úÖ H·∫øt nh·∫°c trong queue!")
            else:
                # Auto DJ 24/7 failed - try again in 30 seconds to avoid spam
                print("‚è≥ Auto DJ waiting 30s before retry...")
                await asyncio.sleep(30)
                await self.play_next(ctx)

    @commands.command(name='fix_volume')
    @commands.has_permissions(administrator=True)
    async def debug_audio(self, ctx):
        """Debug audio issues"""
        try:
            if not ctx.voice_client:
                await ctx.send("‚ùå Bot kh√¥ng trong voice channel!")
                return
            
            embed = discord.Embed(title="üîß Audio Debug Info", color=discord.Color.blue())
            
            # Voice client status
            embed.add_field(
                name="ÔøΩ Voice Client Status",
                value=f"```\nConnected: {ctx.voice_client.is_connected()}\n" +
                      f"Playing: {ctx.voice_client.is_playing()}\n" +
                      f"Paused: {ctx.voice_client.is_paused()}\n" +
                      f"Channel: {ctx.voice_client.channel.name if ctx.voice_client.channel else 'None'}\n```",
                inline=False
            )
            
            # Volume info
            if ctx.voice_client.source and hasattr(ctx.voice_client.source, 'volume'):
                volume = ctx.voice_client.source.volume
                embed.add_field(
                    name="üîä Volume Info",
                    value=f"```\nBot Volume: {volume:.2f} ({int(volume*100)}%)\n```",
                    inline=False
                )
            
            # Queue info
            queue = self.get_queue(ctx.guild.id)
            queue_info = f"Current: {queue.current['title'] if queue.current else 'None'}\n"
            queue_info += f"Queue size: {len(queue.queue)}\n"
            queue_info += f"Loop: {queue.loop}\n"
            queue_info += f"Shuffle: {queue.shuffle_mode}"
            
            embed.add_field(
                name="üìù Queue Info",
                value=f"```\n{queue_info}\n```",
                inline=False
            )
            
            await ctx.send(embed=embed)
            
        except Exception as e:
            await ctx.send(f"‚ùå Debug error: {e}")

    @commands.command(name='musichealth')
    async def music_health_check(self, ctx):
        """Ki·ªÉm tra t√¨nh tr·∫°ng h·ªá th·ªëng nh·∫°c"""
        embed = discord.Embed(
            title="üè• Music System Health Check",
            color=0x00ff00
        )
        
        # Check voice connection
        if ctx.voice_client:
            embed.add_field(
                name="üîä Voice Connection", 
                value=f"‚úÖ Connected to `{ctx.voice_client.channel.name}`",
                inline=False
            )
            embed.add_field(
                name="üéµ Playing Status",
                value=f"Playing: {ctx.voice_client.is_playing()}\nPaused: {ctx.voice_client.is_paused()}",
                inline=True
            )
        else:
            embed.add_field(
                name="üîä Voice Connection", 
                value="‚ùå Not connected to voice channel",
                inline=False
            )
        
        # Check queue
        queue = self.get_queue(ctx.guild.id)
        embed.add_field(
            name="üìù Queue Status",
            value=f"Songs in queue: {len(queue.queue)}\nCurrent: {queue.current.get('title', 'None') if queue.current else 'None'}",
            inline=True
        )
        
        # Check ffmpeg
        try:
            import subprocess
            result = subprocess.run(['ffmpeg', '-version'], capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                embed.add_field(name="üîß FFmpeg", value="‚úÖ Available", inline=True)
            else:
                embed.add_field(name="üîß FFmpeg", value="‚ùå Error", inline=True)
        except:
            embed.add_field(name="üîß FFmpeg", value="‚ùå Not found", inline=True)
        
        # Check yt-dlp
        try:
            import yt_dlp
            embed.add_field(name="üì• yt-dlp", value=f"‚úÖ Version: {yt_dlp.version.__version__}", inline=True)
        except:
            embed.add_field(name="üì• yt-dlp", value="‚ùå Error", inline=True)
        
        await ctx.send(embed=embed)

    @ChannelManager.music_only()
    @commands.command(name='play', aliases=['nhac'])
    async def play(self, ctx, *, search):
        """Ph√°t nh·∫°c t·ª´ YouTube ho·∫∑c URL"""
        if not ctx.author.voice:
            await ctx.send("‚ùå B·∫°n c·∫ßn v√†o voice channel tr∆∞·ªõc!")
            return

        # Ki·ªÉm tra conflict v·ªõi Music Manager
        if hasattr(self.bot, 'music_manager'):
            from .music_manager import MusicSource
            can_proceed, conflict_message, conflict_source = await self.bot.music_manager.request_music_control(
                ctx.guild.id, MusicSource.YOUTUBE, ctx=ctx
            )
            
            if not can_proceed:
                # T·∫°o view ƒë·ªÉ resolve conflict
                view = self.bot.music_manager.create_conflict_resolution_view(
                    ctx.guild.id, MusicSource.YOUTUBE, conflict_source
                )
                await ctx.send(embed=conflict_message, view=view)
                return

        voice_channel = ctx.author.voice.channel
        # C·∫£nh b√°o bitrate n·∫øu th·∫•p
        try:
            if voice_channel.bitrate and voice_channel.bitrate < 192000:
                await ctx.send("‚ö†Ô∏è Bitrate k√™nh voice th·∫•p (<192kbps), ch·∫•t l∆∞·ª£ng c√≥ th·ªÉ b·ªã gi·ªõi h·∫°n. TƒÉng bitrate n·∫øu server ƒë∆∞·ª£c boost.")
        except Exception:
            pass
        # Ensure bot connects to voice channel
        try:
            if ctx.voice_client is None:
                await voice_channel.connect()
                await ctx.send(f"üîó ƒê√£ k·∫øt n·ªëi t·ªõi **{voice_channel.name}**")
            elif ctx.voice_client.channel != voice_channel:
                await ctx.voice_client.move_to(voice_channel)
                await ctx.send(f"üîÑ ƒê√£ chuy·ªÉn t·ªõi **{voice_channel.name}**")
        except Exception as e:
            await ctx.send(f"‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi voice channel: {str(e)}")
            return

        async with ctx.typing():
            url_pattern = re.compile(r'https?://')
            if url_pattern.match(search):
                # H·ªó tr·ª£ YouTube URLs v√† Playlists
                try:
                    loop = self.bot.loop or asyncio.get_event_loop()
                    def extract_url_info():
                        # Cho ph√©p playlist extraction
                        return ytdl.extract_info(search, download=False)
                    data = await loop.run_in_executor(None, extract_url_info)
                    
                    # Ki·ªÉm tra n·∫øu l√† playlist
                    if 'entries' in data and len(data['entries']) > 1:
                        # ƒê√¢y l√† playlist
                        playlist_title = data.get('title', 'YouTube Playlist')
                        entries = data['entries']
                        
                        await ctx.send(f"üéµ ƒêang th√™m playlist: **{playlist_title}** ({len(entries)} b√†i h√°t)...")
                        
                        queue = self.get_queue(ctx.guild.id)
                        added_count = 0
                        
                        # Th√™m t·ª´ng b√†i v√†o queue
                        for i, entry in enumerate(entries):
                            if entry:  # Ki·ªÉm tra entry kh√¥ng null
                                try:
                                    if not ctx.voice_client.is_playing() and not ctx.voice_client.is_paused() and i == 0:
                                        # Ph√°t b√†i ƒë·∫ßu ti√™n ngay
                                        player = await self.create_player(entry, ctx.guild.id)
                                        queue.current = entry
                                        
                                        def after_playing(error):
                                            if error:
                                                print(f"‚ùå Player error: {error}")
                                                if self.is_ffmpeg_expected_error(str(error)):
                                                    print(f"‚úÖ Expected FFmpeg error - continuing normally")
                                                else:
                                                    print(f"‚ö†Ô∏è Unexpected error: {error}")
                                            else:
                                                print(f"‚úÖ Song finished playing normally")
                                            
                                            if ctx.voice_client and ctx.voice_client.is_connected():
                                                try:
                                                    coro = self.play_next(ctx)
                                                    asyncio.run_coroutine_threadsafe(coro, self.bot.loop)
                                                except Exception as next_error:
                                                    print(f"‚ùå Error scheduling next song: {next_error}")
                                        
                                        ctx.voice_client.play(player, after=after_playing)
                                        added_count += 1
                                        
                                        # Hi·ªÉn th·ªã embed cho b√†i ƒë·∫ßu ti√™n
                                        platform_info = "üé¨ YouTube Playlist"
                                        embed = discord.Embed(title="üéµ ƒêang ph√°t t·ª´ playlist", description=f"**{player.title}**", color=0x00ff00)
                                        embed.add_field(name="N·ªÅn t·∫£ng", value=platform_info, inline=True)
                                        if player.uploader:
                                            embed.add_field(name="K√™nh", value=player.uploader, inline=True)
                                        if entry.get('duration'):
                                            embed.add_field(name="Th·ªùi l∆∞·ª£ng", value=self.format_duration(entry['duration']), inline=True)
                                        embed.add_field(name="Playlist", value=f"{playlist_title} (b√†i 1/{len(entries)})", inline=False)
                                        if player.thumbnail:
                                            embed.set_thumbnail(url=player.thumbnail)
                                        
                                        view = MusicControlView(self.bot, ctx.guild.id)
                                        view.message = await ctx.send(embed=embed, view=view)
                                        
                                        # ƒêƒÉng k√Ω message ƒë·ªÉ auto cleanup sau 10 ph√∫t
                                        auto_cleanup_cog = self.bot.get_cog('AutoCleanupCog')
                                        if auto_cleanup_cog:
                                            auto_cleanup_cog.add_message_for_cleanup(view.message, delete_after=600)
                                    else:
                                        # Th√™m v√†o queue
                                        queue.add(entry)
                                        added_count += 1
                                except Exception as e:
                                    print(f"‚ùå Error processing playlist entry {i+1}: {e}")
                                    continue
                        
                        if added_count > 1:
                            await ctx.send(f"‚úÖ ƒê√£ th√™m **{added_count}** b√†i h√°t t·ª´ playlist v√†o queue!")
                        elif added_count == 0:
                            await ctx.send("‚ùå Kh√¥ng th·ªÉ th√™m b√†i h√°t n√†o t·ª´ playlist!")
                        return
                        
                    elif 'entries' in data:
                        # Single video from playlist URL
                        data = data['entries'][0]
                    
                    if not data:
                        await ctx.send("‚ùå Kh√¥ng th·ªÉ t·∫£i nh·∫°c t·ª´ URL n√†y!")
                        return
                except Exception as e:
                    await ctx.send(f"‚ùå L·ªói: {e}")
                    return
            else:
                data = await YTDLSource.search_youtube(search)
                if not data:
                    await ctx.send("‚ùå Kh√¥ng t√¨m th·∫•y b√†i h√°t tr√™n YouTube!\n"
                                 "üí° **G·ª£i √Ω:**\n"
                                 "‚Ä¢ Th·ª≠ t√¨m v·ªõi t√™n ngh·ªá sƒ© + t√™n b√†i\n"
                                 "‚Ä¢ Th√™m t·ª´ kh√≥a 'official', 'mv', 'music video'\n"
                                 "‚Ä¢ Ki·ªÉm tra ch√≠nh t·∫£ t√™n b√†i h√°t")
                    return
            
            queue = self.get_queue(ctx.guild.id)
            if not ctx.voice_client.is_playing() and not ctx.voice_client.is_paused():
                try:
                    player = await self.create_player(data, ctx.guild.id)
                    queue.current = data
                    
                    # Voice client status
                    print(f"üîä Voice client status: Connected={ctx.voice_client.is_connected()}")
                    print(f"üîä Voice channel: {ctx.voice_client.channel.name if ctx.voice_client.channel else 'None'}")
                    
                    def after_playing(error):
                        if error:
                            print(f"‚ùå Player error: {error}")
                            print(f"üîç Error type: {type(error).__name__}")
                            
                            # Use smart error checking
                            if self.is_ffmpeg_expected_error(str(error)):
                                print(f"‚úÖ Expected FFmpeg error - continuing normally")
                            else:
                                print(f"‚ö†Ô∏è Unexpected error, may need investigation: {error}")
                        else:
                            print(f"‚úÖ Song finished playing normally")
                        
                        # Only continue to next song if voice client is still connected and no critical error
                        if ctx.voice_client and ctx.voice_client.is_connected():
                            try:
                                coro = self.play_next(ctx)
                                asyncio.run_coroutine_threadsafe(coro, self.bot.loop)
                            except Exception as next_error:
                                print(f"‚ùå Error scheduling next song: {next_error}")
                    
                    print(f"üéµ Starting playback...")
                    ctx.voice_client.play(player, after=after_playing)
                    print(f"üîä Is playing: {ctx.voice_client.is_playing()}")
                    print(f"üîä Is paused: {ctx.voice_client.is_paused()}")
                    
                    # Detect platform ƒë·ªÉ hi·ªÉn th·ªã icon ƒë√∫ng
                    platform_info = "üé¨ YouTube"
                    
                    embed = discord.Embed(title="üéµ ƒêang ph√°t", description=f"**{player.title}**", color=0x00ff00)
                    embed.add_field(name="N·ªÅn t·∫£ng", value=platform_info, inline=True)
                    if player.uploader:
                        embed.add_field(name="K√™nh", value=player.uploader, inline=True)
                    if data.get('duration'):
                        embed.add_field(name="Th·ªùi l∆∞·ª£ng", value=self.format_duration(data['duration']), inline=True)
                    if player.thumbnail:
                        embed.set_thumbnail(url=player.thumbnail)
                    view = MusicControlView(self.bot, ctx.guild.id)
                    view.message = await ctx.send(embed=embed, view=view)
                    
                    # ƒêƒÉng k√Ω message ƒë·ªÉ auto cleanup sau 10 ph√∫t
                    auto_cleanup_cog = self.bot.get_cog('AutoCleanupCog')
                    if auto_cleanup_cog:
                        auto_cleanup_cog.add_message_for_cleanup(view.message, delete_after=600)
                except Exception as e:
                    await ctx.send(f"‚ùå L·ªói khi ph√°t nh·∫°c: {e}")
            else:
                queue.add(data)
                
                # Detect platform ƒë·ªÉ hi·ªÉn th·ªã icon ƒë√∫ng
                platform_info = "üé¨ YouTube"
                
                embed = discord.Embed(title="üìù ƒê√£ th√™m v√†o queue", description=f"**{data['title']}**", color=0x0099ff)
                embed.add_field(name="N·ªÅn t·∫£ng", value=platform_info, inline=True)
                embed.add_field(name="V·ªã tr√≠", value=f"#{len(queue.queue)}", inline=True)
                if data.get('uploader'):
                    embed.add_field(name="K√™nh", value=data['uploader'], inline=True)
                if data.get('duration'):
                    embed.add_field(name="Th·ªùi l∆∞·ª£ng", value=self.format_duration(data['duration']), inline=True)
                if data.get('thumbnail'):
                    embed.set_thumbnail(url=data['thumbnail'])
                await ctx.send(embed=embed)

    @ChannelManager.music_only()
    @commands.command(name='pause')
    async def pause(self, ctx):
        """T·∫°m d·ª´ng nh·∫°c"""
        if ctx.voice_client and ctx.voice_client.is_playing():
            ctx.voice_client.pause()
            await ctx.send("‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng nh·∫°c!")
        else:
            await ctx.send("‚ùå Kh√¥ng c√≥ nh·∫°c ƒëang ph√°t!")

    @ChannelManager.music_only()
    @commands.command(name='resume')
    async def resume(self, ctx):
        """Ti·∫øp t·ª•c ph√°t nh·∫°c"""
        if ctx.voice_client and ctx.voice_client.is_paused():
            ctx.voice_client.resume()
            await ctx.send("‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c!")
        else:
            await ctx.send("‚ùå Nh·∫°c kh√¥ng b·ªã t·∫°m d·ª´ng!")

    @ChannelManager.music_only()
    @commands.command(name='skip', aliases=['boqua'])
    async def skip(self, ctx):
        """B·ªè qua b√†i h√°t hi·ªán t·∫°i"""
        if ctx.voice_client and ctx.voice_client.is_playing():
            ctx.voice_client.stop()
            await ctx.send("‚è≠Ô∏è ƒê√£ b·ªè qua b√†i h√°t!")
        else:
            await ctx.send("‚ùå Kh√¥ng c√≥ nh·∫°c ƒëang ph√°t!")

    @ChannelManager.music_only()
    @commands.command(name='stop')
    async def stop(self, ctx):
        """D·ª´ng nh·∫°c v√† x√≥a queue"""
        queue = self.get_queue(ctx.guild.id)
        queue.clear()
        
        if ctx.voice_client:
            if ctx.voice_client.is_playing():
                ctx.voice_client.stop()
            await ctx.voice_client.disconnect()
            await ctx.send("‚èπÔ∏è ƒê√£ d·ª´ng nh·∫°c v√† r·ªùi kh·ªèi voice channel!")
        else:
            await ctx.send("‚ùå Bot kh√¥ng ·ªü trong voice channel!")

    @ChannelManager.music_only()
    @commands.command(name='queue', aliases=['hangcho'])
    async def show_queue(self, ctx):
        """Hi·ªÉn th·ªã queue nh·∫°c"""
        queue = self.get_queue(ctx.guild.id)
        
        if not queue.queue and not queue.current:
            await ctx.send("üìù Queue tr·ªëng!")
            return

        embed = discord.Embed(title="üéµ Music Queue", color=0x0099ff)
        
        if queue.current:
            embed.add_field(
                name="üéµ ƒêang ph√°t",
                value=f"**{queue.current['title']}**",
                inline=False
            )

        if queue.queue:
            queue_list = []
            for i, song in enumerate(list(queue.queue)[:10], 1):
                queue_list.append(f"**{i}.** {song['title']}")
            
            embed.add_field(
                name="üìù Ti·∫øp theo",
                value="\n".join(queue_list),
                inline=False
            )
            
            if len(queue.queue) > 10:
                embed.add_field(
                    name="‚ûï V√† h∆°n n·ªØa",
                    value=f"**{len(queue.queue) - 10}** b√†i h√°t kh√°c...",
                    inline=False
                )

        await ctx.send(embed=embed)

    @commands.command(name='clearqueue')
    async def clear_queue(self, ctx):
        """X√≥a t·∫•t c·∫£ nh·∫°c trong queue"""
        queue = self.get_queue(ctx.guild.id)
        queue.clear()
        await ctx.send("üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ nh·∫°c trong queue!")

    @commands.command(name='shuffle')
    async def shuffle_queue(self, ctx):
        """X√°o tr·ªôn queue"""
        queue = self.get_queue(ctx.guild.id)
        if len(queue.queue) > 1:
            queue.shuffle()
            await ctx.send("üîÄ ƒê√£ x√°o tr·ªôn queue!")
        else:
            await ctx.send("‚ùå C·∫ßn √≠t nh·∫•t 2 b√†i h√°t trong queue ƒë·ªÉ x√°o tr·ªôn!")

    @ChannelManager.music_only()
    @commands.command(name='volume', aliases=['vol'])
    async def volume(self, ctx, volume: int = None):
        """Thay ƒë·ªïi √¢m l∆∞·ª£ng (0-100)"""
        if ctx.voice_client is None:
            return await ctx.send("‚ùå Bot kh√¥ng ·ªü trong voice channel!")

        if volume is None:
            current_volume = int(ctx.voice_client.source.volume * 100) if hasattr(ctx.voice_client.source, 'volume') else 50
            await ctx.send(f"üîä √Çm l∆∞·ª£ng hi·ªán t·∫°i: **{current_volume}%**")
            return

        if volume < 0 or volume > 100:
            await ctx.send("‚ùå √Çm l∆∞·ª£ng ph·∫£i t·ª´ 0 ƒë·∫øn 100!")
            return

        if hasattr(ctx.voice_client.source, 'volume'):
            ctx.voice_client.source.volume = volume / 100
            await ctx.send(f"üîä ƒê√£ ƒë·∫∑t √¢m l∆∞·ª£ng th√†nh **{volume}%**")
        else:
            await ctx.send("‚ùå Kh√¥ng th·ªÉ thay ƒë·ªïi √¢m l∆∞·ª£ng!")

    @commands.command(name='nowplaying', aliases=['np'])
    async def now_playing(self, ctx):
        """Hi·ªÉn th·ªã b√†i h√°t ƒëang ph√°t"""
        queue = self.get_queue(ctx.guild.id)
        
        if not queue.current:
            await ctx.send("‚ùå Kh√¥ng c√≥ nh·∫°c ƒëang ph√°t!")
            return

        current = queue.current
        embed = discord.Embed(
            title="üéµ ƒêang ph√°t",
            description=f"**{current['title']}**",
            color=0x00ff00
        )
        
        if current.get('uploader'):
            embed.add_field(name="K√™nh", value=current['uploader'], inline=True)
        if current.get('duration'):
            duration_str = self.format_duration(current['duration'])
            embed.add_field(name="Th·ªùi l∆∞·ª£ng", value=duration_str, inline=True)
        if current.get('thumbnail'):
            embed.set_thumbnail(url=current['thumbnail'])
        
        embed.add_field(name="URL", value=f"[Li√™n k·∫øt]({current['webpage_url']})", inline=False)
        
        await ctx.send(embed=embed)

    # =============== SLASH COMMANDS ===============
    
    @app_commands.command(name="play", description="Ph√°t nh·∫°c t·ª´ YouTube")
    @app_commands.describe(search="T√™n b√†i h√°t ho·∫∑c URL YouTube")
    async def slash_play(self, interaction: discord.Interaction, search: str):
        """Slash command for playing music"""
        await self.play_command(interaction, search)
    
    @app_commands.command(name="pause", description="T·∫°m d·ª´ng nh·∫°c")
    async def slash_pause(self, interaction: discord.Interaction):
        """Slash command for pausing music"""
        if interaction.guild.voice_client and interaction.guild.voice_client.is_playing():
            interaction.guild.voice_client.pause()
            await interaction.response.send_message("‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng nh·∫°c!", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Kh√¥ng c√≥ nh·∫°c ƒëang ph√°t!", ephemeral=True)
    
    @app_commands.command(name="resume", description="Ti·∫øp t·ª•c ph√°t nh·∫°c")
    async def slash_resume(self, interaction: discord.Interaction):
        """Slash command for resuming music"""
        if interaction.guild.voice_client and interaction.guild.voice_client.is_paused():
            interaction.guild.voice_client.resume()
            await interaction.response.send_message("‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c!", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Nh·∫°c kh√¥ng b·ªã t·∫°m d·ª´ng!", ephemeral=True)
    
    @app_commands.command(name="skip", description="B·ªè qua b√†i h√°t hi·ªán t·∫°i")
    async def slash_skip(self, interaction: discord.Interaction):
        """Slash command for skipping song"""
        if interaction.guild.voice_client and interaction.guild.voice_client.is_playing():
            interaction.guild.voice_client.stop()
            await interaction.response.send_message("‚è≠Ô∏è ƒê√£ b·ªè qua b√†i h√°t!", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Kh√¥ng c√≥ nh·∫°c ƒëang ph√°t!", ephemeral=True)
    
    @app_commands.command(name="stop", description="D·ª´ng nh·∫°c v√† r·ªùi kh·ªèi voice channel")
    async def slash_stop(self, interaction: discord.Interaction):
        """Slash command for stopping music"""
        queue = self.get_queue(interaction.guild.id)
        queue.clear()
        
        if interaction.guild.voice_client:
            if interaction.guild.voice_client.is_playing():
                interaction.guild.voice_client.stop()
            await interaction.guild.voice_client.disconnect()
            await interaction.response.send_message("‚èπÔ∏è ƒê√£ d·ª´ng nh·∫°c v√† r·ªùi kh·ªèi voice channel!", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Bot kh√¥ng ·ªü trong voice channel!", ephemeral=True)
    
    @app_commands.command(name="queue", description="Hi·ªÉn th·ªã queue nh·∫°c")
    async def slash_queue(self, interaction: discord.Interaction):
        """Slash command for showing queue"""
        await interaction.response.defer()
        
        queue = self.get_queue(interaction.guild.id)
        
        if not queue.queue and not queue.current:
            await interaction.followup.send("üìù Queue tr·ªëng!")
            return

        embed = discord.Embed(title="üéµ Music Queue", color=0x0099ff)
        
        if queue.current:
            embed.add_field(
                name="üéµ ƒêang ph√°t",
                value=f"**{queue.current['title']}**",
                inline=False
            )

        if queue.queue:
            queue_list = []
            for i, song in enumerate(list(queue.queue)[:10], 1):
                queue_list.append(f"**{i}.** {song['title']}")
            
            embed.add_field(
                name="üìù Ti·∫øp theo",
                value="\n".join(queue_list),
                inline=False
            )
            
            if len(queue.queue) > 10:
                embed.add_field(
                    name="‚ûï V√† h∆°n n·ªØa",
                    value=f"**{len(queue.queue) - 10}** b√†i h√°t kh√°c...",
                    inline=False
                )

        await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="shuffle", description="X√°o tr·ªôn queue nh·∫°c")
    async def slash_shuffle(self, interaction: discord.Interaction):
        """Slash command for shuffling queue"""
        queue = self.get_queue(interaction.guild.id)
        if len(queue.queue) > 1:
            queue.shuffle()
            await interaction.response.send_message("üîÄ ƒê√£ x√°o tr·ªôn queue!", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå C·∫ßn √≠t nh·∫•t 2 b√†i h√°t trong queue ƒë·ªÉ x√°o tr·ªôn!", ephemeral=True)
    
    @app_commands.command(name="volume", description="Thay ƒë·ªïi √¢m l∆∞·ª£ng (0-100)")
    @app_commands.describe(level="M·ª©c √¢m l∆∞·ª£ng t·ª´ 0 ƒë·∫øn 100")
    async def slash_volume(self, interaction: discord.Interaction, level: int):
        """Slash command for changing volume"""
        if level < 0 or level > 100:
            await interaction.response.send_message("‚ùå √Çm l∆∞·ª£ng ph·∫£i t·ª´ 0 ƒë·∫øn 100!", ephemeral=True)
            return
        
        if interaction.guild.voice_client is None:
            await interaction.response.send_message("‚ùå Bot kh√¥ng ·ªü trong voice channel!", ephemeral=True)
            return

        if hasattr(interaction.guild.voice_client.source, 'volume'):
            interaction.guild.voice_client.source.volume = level / 100
            await interaction.response.send_message(f"üîä ƒê√£ ƒë·∫∑t √¢m l∆∞·ª£ng th√†nh **{level}%**", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Kh√¥ng th·ªÉ thay ƒë·ªïi √¢m l∆∞·ª£ng!", ephemeral=True)
    
    @app_commands.command(name="nowplaying", description="Hi·ªÉn th·ªã b√†i h√°t ƒëang ph√°t")
    async def slash_nowplaying(self, interaction: discord.Interaction):
        """Slash command for now playing"""
        await interaction.response.defer()
        
        queue = self.get_queue(interaction.guild.id)
        
        if not queue.current:
            await interaction.followup.send("‚ùå Kh√¥ng c√≥ nh·∫°c ƒëang ph√°t!", ephemeral=True)
            return

        current = queue.current
        embed = discord.Embed(
            title="üéµ ƒêang ph√°t",
            description=f"**{current['title']}**",
            color=discord.Color.green()
        )
        
        if current.get('uploader'):
            embed.add_field(name="K√™nh", value=current['uploader'], inline=True)
        if current.get('duration'):
            duration_str = self.format_duration(current['duration'])
            embed.add_field(name="Th·ªùi l∆∞·ª£ng", value=duration_str, inline=True)
        if current.get('thumbnail'):
            embed.set_thumbnail(url=current['thumbnail'])
        
        embed.add_field(name="URL", value=f"[Li√™n k·∫øt]({current['webpage_url']})", inline=False)
        
        # Add control panel
        view = MusicControlView(self.bot, interaction.guild.id)
        message = await interaction.followup.send(embed=embed, view=view)
        
        # ƒêƒÉng k√Ω message ƒë·ªÉ auto cleanup sau 10 ph√∫t
        auto_cleanup_cog = self.bot.get_cog('AutoCleanupCog')
        if auto_cleanup_cog:
            auto_cleanup_cog.add_message_for_cleanup(message, delete_after=600)
    
    @app_commands.command(name="clearqueue", description="X√≥a t·∫•t c·∫£ nh·∫°c trong queue")
    async def slash_clearqueue(self, interaction: discord.Interaction):
        """Slash command for clearing queue"""
        await interaction.response.defer()
        
        queue = self.get_queue(interaction.guild.id)
        queue.clear()
        
        embed = discord.Embed(
            title="üóëÔ∏è Queue ƒë√£ ƒë∆∞·ª£c x√≥a",
            description="ƒê√£ x√≥a t·∫•t c·∫£ nh·∫°c trong queue!",
            color=discord.Color.orange()
        )
        await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="loop", description="Thay ƒë·ªïi ch·∫ø ƒë·ªô l·∫∑p l·∫°i")
    @app_commands.describe(mode="Ch·∫ø ƒë·ªô l·∫∑p: off, song, queue")
    @app_commands.choices(mode=[
        app_commands.Choice(name="T·∫Øt", value="off"),
        app_commands.Choice(name="L·∫∑p b√†i h√°t", value="song"),
        app_commands.Choice(name="L·∫∑p queue", value="queue")
    ])
    async def slash_loop(self, interaction: discord.Interaction, mode: str):
        """Slash command for loop mode"""
        queue = self.get_queue(interaction.guild.id)
        queue.loop_mode = mode
        
        mode_text = {
            "off": "üîÑ ƒê√£ t·∫Øt ch·∫ø ƒë·ªô l·∫∑p l·∫°i",
            "song": "üîÇ ƒê√£ b·∫≠t l·∫∑p l·∫°i b√†i h√°t hi·ªán t·∫°i",
            "queue": "üîÅ ƒê√£ b·∫≠t l·∫∑p l·∫°i queue"
        }
        
        await interaction.response.send_message(mode_text.get(mode, "‚ùå Ch·∫ø ƒë·ªô kh√¥ng h·ª£p l·ªá!"), ephemeral=True)
    
    @app_commands.command(name="lyrics", description="T√¨m l·ªùi b√†i h√°t")
    @app_commands.describe(song_name="T√™n b√†i h√°t (ƒë·ªÉ tr·ªëng ƒë·ªÉ l·∫•y b√†i ƒëang ph√°t)")
    async def slash_lyrics(self, interaction: discord.Interaction, song_name: str = None):
        """Slash command for lyrics"""
        await interaction.response.defer()
        
        if not song_name:
            queue = self.get_queue(interaction.guild.id)
            if queue.current:
                song_name = queue.current.get('title', None)
            
            if not song_name:
                await interaction.followup.send("‚ùå Vui l√≤ng cung c·∫•p t√™n b√†i h√°t ho·∫∑c ph√°t nh·∫°c tr∆∞·ªõc!", ephemeral=True)
                return
        
        embed = discord.Embed(
            title=f"üéµ Lyrics: {song_name}",
            description="T√≠nh nƒÉng lyrics ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn...",
            color=discord.Color.blue()
        )
        await interaction.followup.send(embed=embed)
    
    # =============== PLAYLIST SLASH COMMANDS ===============
    
    @app_commands.command(name="playlist-create", description="T·∫°o playlist t·ª´ queue hi·ªán t·∫°i")
    @app_commands.describe(name="T√™n playlist")
    async def slash_playlist_create(self, interaction: discord.Interaction, name: str):
        """Slash command for creating playlist"""
        await interaction.response.defer()
        
        user_id = interaction.user.id
        music_queue = self.get_queue(interaction.guild.id)
        
        current_songs = []
        if music_queue.current:
            current_songs.append({
                'title': music_queue.current.get('title', 'Unknown'),
                'url': music_queue.current.get('webpage_url', ''),
                'duration': music_queue.current.get('duration', 0)
            })
        
        for song in music_queue.queue:
            current_songs.append({
                'title': song.get('title', 'Unknown'),
                'url': song.get('webpage_url', ''),
                'duration': song.get('duration', 0)
            })
        
        if not current_songs:
            await interaction.followup.send("‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o trong queue ƒë·ªÉ t·∫°o playlist!", ephemeral=True)
            return
        
        music_queue.save_playlist(user_id, name, current_songs)
        
        embed = discord.Embed(
            title="‚úÖ Playlist ƒë√£ ƒë∆∞·ª£c t·∫°o",
            description=f"ƒê√£ t·∫°o playlist **{name}** v·ªõi {len(current_songs)} b√†i h√°t!",
            color=discord.Color.green()
        )
        await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="playlist-load", description="Load playlist v√†o queue")
    @app_commands.describe(name="T√™n playlist")
    async def slash_playlist_load(self, interaction: discord.Interaction, name: str):
        """Slash command for loading playlist"""
        await interaction.response.defer()
        
        user_id = interaction.user.id
        music_queue = self.get_queue(interaction.guild.id)
        
        playlist_songs = music_queue.get_playlist(user_id, name)
        if not playlist_songs:
            await interaction.followup.send(f"‚ùå Kh√¥ng t√¨m th·∫•y playlist **{name}**!", ephemeral=True)
            return
        
        queue = self.get_queue(interaction.guild.id)
        queue.clear()
        loaded_count = 0
        
        for song_data in playlist_songs:
            try:
                queue.add(song_data)
                loaded_count += 1
            except:
                continue
        
        embed = discord.Embed(
            title="‚úÖ Playlist ƒë√£ ƒë∆∞·ª£c load",
            description=f"ƒê√£ load {loaded_count} b√†i h√°t t·ª´ playlist **{name}** v√†o queue!",
            color=discord.Color.green()
        )
        await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="playlist-list", description="Hi·ªÉn th·ªã t·∫•t c·∫£ playlist")
    async def slash_playlist_list(self, interaction: discord.Interaction):
        """Slash command for listing playlists"""
        await interaction.response.defer()
        
        user_id = interaction.user.id
        music_queue = self.get_queue(interaction.guild.id)
        
        playlists = music_queue.list_playlists(user_id)
        if not playlists:
            await interaction.followup.send("üìù B·∫°n ch∆∞a c√≥ playlist n√†o!", ephemeral=True)
            return
        
        embed = discord.Embed(title="üéµ Danh s√°ch Playlist", color=discord.Color.blue())
        for i, playlist in enumerate(playlists, 1):
            song_count = len(music_queue.get_playlist(user_id, playlist))
            embed.add_field(name=f"{i}. {playlist}", value=f"{song_count} b√†i h√°t", inline=False)
        
        await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="playlist-show", description="Hi·ªÉn th·ªã chi ti·∫øt playlist")
    @app_commands.describe(name="T√™n playlist")
    async def slash_playlist_show(self, interaction: discord.Interaction, name: str):
        """Slash command for showing playlist details"""
        await interaction.response.defer()
        
        user_id = interaction.user.id
        music_queue = self.get_queue(interaction.guild.id)
        
        playlist_songs = music_queue.get_playlist(user_id, name)
        if not playlist_songs:
            await interaction.followup.send(f"‚ùå Kh√¥ng t√¨m th·∫•y playlist **{name}**!", ephemeral=True)
            return
        
        embed = discord.Embed(title=f"üéµ Playlist: {name}", color=discord.Color.blue())
        
        total_duration = 0
        for i, song in enumerate(playlist_songs[:10], 1):
            duration = song.get('duration', 0)
            total_duration += duration
            duration_str = f"{duration//60}:{duration%60:02d}" if duration else "N/A"
            embed.add_field(
                name=f"{i}. {song['title'][:50]}",
                value=f"‚è±Ô∏è {duration_str}",
                inline=False
            )
        
        if len(playlist_songs) > 10:
            embed.add_field(name="...", value=f"V√† {len(playlist_songs)-10} b√†i kh√°c", inline=False)
        
        total_duration_str = f"{total_duration//60}:{total_duration%60:02d}"
        embed.set_footer(text=f"T·ªïng c·ªông: {len(playlist_songs)} b√†i h√°t ‚Ä¢ {total_duration_str}")
        
        await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="playlist-delete", description="X√≥a playlist")
    @app_commands.describe(name="T√™n playlist")
    async def slash_playlist_delete(self, interaction: discord.Interaction, name: str):
        """Slash command for deleting playlist"""
        await interaction.response.defer()
        
        user_id = interaction.user.id
        music_queue = self.get_queue(interaction.guild.id)
        
        if music_queue.delete_playlist(user_id, name):
            embed = discord.Embed(
                title="‚úÖ Playlist ƒë√£ ƒë∆∞·ª£c x√≥a",
                description=f"ƒê√£ x√≥a playlist **{name}**!",
                color=discord.Color.green()
            )
        else:
            embed = discord.Embed(
                title="‚ùå L·ªói",
                description=f"Kh√¥ng t√¨m th·∫•y playlist **{name}**!",
                color=discord.Color.red()
            )
        
        await interaction.followup.send(embed=embed)
    
    # =============== FAVORITE SLASH COMMANDS ===============
    
    @app_commands.command(name="favorite-add", description="Th√™m b√†i ƒëang ph√°t v√†o y√™u th√≠ch")
    async def slash_favorite_add(self, interaction: discord.Interaction):
        """Slash command for adding to favorites"""
        await interaction.response.defer()
        
        user_id = interaction.user.id
        queue = self.get_queue(interaction.guild.id)
        
        if not queue.current:
            await interaction.followup.send("‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!", ephemeral=True)
            return
        
        song_data = {
            'title': queue.current.get('title', 'Unknown'),
            'url': queue.current.get('webpage_url', ''),
            'duration': queue.current.get('duration', 0)
        }
        
        favorites = queue.get_playlist(user_id, "Favorites")
        if not any(song['url'] == song_data['url'] for song in favorites):
            favorites.append(song_data)
            queue.save_playlist(user_id, "Favorites", favorites)
            
            embed = discord.Embed(
                title="‚ù§Ô∏è ƒê√£ th√™m v√†o y√™u th√≠ch",
                description=f"ƒê√£ th√™m **{song_data['title']}** v√†o danh s√°ch y√™u th√≠ch!",
                color=discord.Color.red()
            )
        else:
            embed = discord.Embed(
                title="‚ùå ƒê√£ t·ªìn t·∫°i",
                description="B√†i h√°t n√†y ƒë√£ c√≥ trong danh s√°ch y√™u th√≠ch!",
                color=discord.Color.orange()
            )
        
        await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="favorite-list", description="Hi·ªÉn th·ªã danh s√°ch y√™u th√≠ch")
    async def slash_favorite_list(self, interaction: discord.Interaction):
        """Slash command for showing favorites"""
        await interaction.response.defer()
        
        user_id = interaction.user.id
        queue = self.get_queue(interaction.guild.id)
        
        favorites = queue.get_playlist(user_id, "Favorites")
        if not favorites:
            await interaction.followup.send("üíî B·∫°n ch∆∞a c√≥ b√†i h√°t y√™u th√≠ch n√†o!", ephemeral=True)
            return
        
        embed = discord.Embed(title="‚ù§Ô∏è B√†i h√°t y√™u th√≠ch", color=discord.Color.red())
        for i, song in enumerate(favorites[:10], 1):
            duration = song.get('duration', 0)
            duration_str = f"{duration//60}:{duration%60:02d}" if duration else "N/A"
            embed.add_field(
                name=f"{i}. {song['title'][:50]}",
                value=f"‚è±Ô∏è {duration_str}",
                inline=False
            )
        
        if len(favorites) > 10:
            embed.add_field(name="...", value=f"V√† {len(favorites)-10} b√†i kh√°c", inline=False)
        
        embed.set_footer(text=f"T·ªïng c·ªông: {len(favorites)} b√†i h√°t")
        await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="favorite-play", description="Ph√°t t·∫•t c·∫£ b√†i h√°t y√™u th√≠ch")
    async def slash_favorite_play(self, interaction: discord.Interaction):
        """Slash command for playing favorites"""
        await interaction.response.defer()
        
        user_id = interaction.user.id
        queue = self.get_queue(interaction.guild.id)
        
        favorites = queue.get_playlist(user_id, "Favorites")
        if not favorites:
            await interaction.followup.send("üíî B·∫°n ch∆∞a c√≥ b√†i h√°t y√™u th√≠ch n√†o!", ephemeral=True)
            return
        
        # Load favorites v√†o queue
        current_queue = self.get_queue(interaction.guild.id)
        current_queue.clear()
        
        for song_data in favorites:
            current_queue.add(song_data)
        
        embed = discord.Embed(
            title="‚ù§Ô∏è ƒê√£ load y√™u th√≠ch",
            description=f"ƒê√£ load {len(favorites)} b√†i h√°t y√™u th√≠ch v√†o queue!",
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed)
    
    # =============== CONTROLS SLASH COMMAND ===============
    
    @app_commands.command(name="controls", description="Hi·ªÉn th·ªã b·ªô ƒëi·ªÅu khi·ªÉn nh·∫°c")
    async def slash_controls(self, interaction: discord.Interaction):
        """Slash command for music controls"""
        await interaction.response.defer()
        
        queue = self.get_queue(interaction.guild.id)
        
        if queue.current:
            embed = discord.Embed(
                title="üéõÔ∏è B·ªô ƒëi·ªÅu khi·ªÉn nh·∫°c",
                description=f"**{queue.current['title']}**",
                color=discord.Color.green()
            )
            if queue.current.get('thumbnail'):
                embed.set_thumbnail(url=queue.current['thumbnail'])
        else:
            embed = discord.Embed(
                title="üéõÔ∏è B·ªô ƒëi·ªÅu khi·ªÉn nh·∫°c",
                description="Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t",
                color=discord.Color.blue()
            )
        
        view = MusicControlView(self.bot, interaction.guild.id)
        message = await interaction.followup.send(embed=embed, view=view)
        
        # ƒêƒÉng k√Ω message ƒë·ªÉ auto cleanup sau 10 ph√∫t
        auto_cleanup_cog = self.bot.get_cog('AutoCleanupCog')
        if auto_cleanup_cog:
            auto_cleanup_cog.add_message_for_cleanup(message, delete_after=600)

    @commands.command(name="playlist", aliases=["pl"])
    async def playlist_command(self, ctx, action=None, playlist_name=None, *, song_query=None):
        """Qu·∫£n l√Ω playlist: create, save, load, list, delete, add"""
        if not action:
            # H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng
            embed = discord.Embed(title="üéµ Playlist Commands", color=discord.Color.blue())
            embed.add_field(name="!playlist create <t√™n>", value="T·∫°o playlist t·ª´ queue hi·ªán t·∫°i", inline=False)
            embed.add_field(name="!playlist add <t√™n> <b√†i h√°t>", value="Th√™m b√†i h√°t v√†o playlist", inline=False)
            embed.add_field(name="!playlist load <t√™n>", value="Load playlist v√†o queue", inline=False)
            embed.add_field(name="!playlist list", value="Hi·ªÉn th·ªã t·∫•t c·∫£ playlist", inline=False)
            embed.add_field(name="!playlist show <t√™n>", value="Hi·ªÉn th·ªã chi ti·∫øt playlist", inline=False)
            embed.add_field(name="!playlist delete <t√™n>", value="X√≥a playlist", inline=False)
            await ctx.send(embed=embed)
            return
            
        user_id = ctx.author.id
        music_queue = self.get_queue(ctx.guild.id)
        
        if action.lower() == "create" and playlist_name:
            # T·∫°o playlist m·ªõi t·ª´ queue hi·ªán t·∫°i
            current_songs = []
            if music_queue.current:
                current_songs.append({
                    'title': music_queue.current.get('title', 'Unknown'),
                    'url': music_queue.current.get('webpage_url', ''),
                    'duration': music_queue.current.get('duration', 0)
                })
            
            for song in music_queue.queue:
                current_songs.append({
                    'title': song.get('title', 'Unknown'),
                    'url': song.get('webpage_url', ''),
                    'duration': song.get('duration', 0)
                })
            
            music_queue.save_playlist(user_id, playlist_name, current_songs)
            await ctx.send(f"‚úÖ ƒê√£ t·∫°o playlist **{playlist_name}** v·ªõi {len(current_songs)} b√†i h√°t!")
            
        elif action.lower() == "add" and playlist_name and song_query:
            # Th√™m b√†i h√°t v√†o playlist
            current_playlist = music_queue.get_playlist(user_id, playlist_name)
            if not current_playlist:
                await ctx.send(f"‚ùå Kh√¥ng t√¨m th·∫•y playlist **{playlist_name}**!")
                return
            
            try:
                # T√¨m b√†i h√°t
                ytdl = YTDLSource.ytdl
                info = await self.bot.loop.run_in_executor(None, lambda: ytdl.extract_info(f"ytsearch:{song_query}", download=False))
                
                if 'entries' in info and len(info['entries']) > 0:
                    entry = info['entries'][0]
                    song_data = {
                        'title': entry.get('title', 'Unknown'),
                        'url': entry.get('webpage_url', entry.get('url', '')),
                        'duration': entry.get('duration', 0)
                    }
                    current_playlist.append(song_data)
                    music_queue.save_playlist(user_id, playlist_name, current_playlist)
                    await ctx.send(f"‚úÖ ƒê√£ th√™m **{song_data['title']}** v√†o playlist **{playlist_name}**!")
                else:
                    await ctx.send("‚ùå Kh√¥ng t√¨m th·∫•y b√†i h√°t!")
            except Exception as e:
                await ctx.send(f"‚ùå L·ªói khi th√™m b√†i h√°t: {str(e)}")
            
        elif action.lower() == "load" and playlist_name:
            # Load playlist v√†o queue
            playlist_songs = music_queue.get_playlist(user_id, playlist_name)
            if not playlist_songs:
                await ctx.send(f"‚ùå Kh√¥ng t√¨m th·∫•y playlist **{playlist_name}**!")
                return
            
            queue = self.get_queue(ctx.guild.id)
            queue.clear()
            loaded_count = 0
            
            for song_data in playlist_songs:
                try:
                    queue.add(song_data)
                    loaded_count += 1
                except:
                    continue
            
            await ctx.send(f"‚úÖ ƒê√£ load {loaded_count} b√†i h√°t t·ª´ playlist **{playlist_name}** v√†o queue!")
            
        elif action.lower() == "list":
            # Li·ªát k√™ t·∫•t c·∫£ playlist
            playlists = music_queue.list_playlists(user_id)
            if not playlists:
                await ctx.send("üìù B·∫°n ch∆∞a c√≥ playlist n√†o!")
                return
            
            embed = discord.Embed(title="üéµ Danh s√°ch Playlist", color=discord.Color.blue())
            for i, playlist in enumerate(playlists, 1):
                song_count = len(music_queue.get_playlist(user_id, playlist))
                embed.add_field(name=f"{i}. {playlist}", value=f"{song_count} b√†i h√°t", inline=False)
            
            await ctx.send(embed=embed)
            
        elif action.lower() == "show" and playlist_name:
            # Hi·ªÉn th·ªã chi ti·∫øt playlist
            playlist_songs = music_queue.get_playlist(user_id, playlist_name)
            if not playlist_songs:
                await ctx.send(f"‚ùå Kh√¥ng t√¨m th·∫•y playlist **{playlist_name}**!")
                return
            
            embed = discord.Embed(title=f"üéµ Playlist: {playlist_name}", color=discord.Color.blue())
            
            total_duration = 0
            for i, song in enumerate(playlist_songs[:10], 1):  # Hi·ªÉn th·ªã 10 b√†i ƒë·∫ßu
                duration = song.get('duration', 0)
                total_duration += duration
                duration_str = f"{duration//60}:{duration%60:02d}" if duration else "N/A"
                embed.add_field(
                    name=f"{i}. {song['title'][:50]}",
                    value=f"‚è±Ô∏è {duration_str}",
                    inline=False
                )
            
            if len(playlist_songs) > 10:
                embed.add_field(name="...", value=f"V√† {len(playlist_songs)-10} b√†i kh√°c", inline=False)
            
            total_duration_str = f"{total_duration//60}:{total_duration%60:02d}"
            embed.set_footer(text=f"T·ªïng c·ªông: {len(playlist_songs)} b√†i h√°t ‚Ä¢ {total_duration_str}")
            
            await ctx.send(embed=embed)
            
        elif action.lower() == "delete" and playlist_name:
            # X√≥a playlist
            if music_queue.delete_playlist(user_id, playlist_name):
                await ctx.send(f"‚úÖ ƒê√£ x√≥a playlist **{playlist_name}**!")
            else:
                await ctx.send(f"‚ùå Kh√¥ng t√¨m th·∫•y playlist **{playlist_name}**!")

    @commands.command(name="lyrics", aliases=["lyr"])
    async def lyrics_command(self, ctx, *, song_name=None):
        """T√¨m l·ªùi b√†i h√°t"""
        if not song_name:
            queue = self.get_queue(ctx.guild.id)
            if queue.current:
                song_name = queue.current.get('title', None)
            if not song_name:
                await ctx.send("‚ùå Vui l√≤ng cung c·∫•p t√™n b√†i h√°t ho·∫∑c ph√°t nh·∫°c tr∆∞·ªõc!")
                return
        try:
            import re  # still potentially used later
            embed = discord.Embed(
                title=f"üéµ Lyrics: {song_name}",
                description="T√≠nh nƒÉng lyrics ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn...",
                color=discord.Color.blue()
            )
            await ctx.send(embed=embed)
        except Exception as e:
            await ctx.send(f"‚ùå L·ªói khi t√¨m l·ªùi b√†i h√°t: {str(e)}")

    @commands.command(name="favorite", aliases=["fav"])
    async def favorite_command(self, ctx, action=None):
        """Qu·∫£n l√Ω b√†i h√°t y√™u th√≠ch"""
        user_id = ctx.author.id
        queue = self.get_queue(ctx.guild.id)
        
        if action == "add":
            current_queue = self.get_queue(ctx.guild.id)
            if not current_queue.current:
                await ctx.send("‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!")
                return
            
            song_data = {
                'title': current_queue.current.get('title', 'Unknown'),
                'url': current_queue.current.get('webpage_url', ''),
                'duration': current_queue.current.get('duration', 0)
            }
            
            # Th√™m v√†o playlist "Favorites"
            favorites = queue.get_playlist(user_id, "Favorites")
            if not any(song['url'] == song_data['url'] for song in favorites):
                favorites.append(song_data)
                queue.save_playlist(user_id, "Favorites", favorites)
                await ctx.send(f"‚ù§Ô∏è ƒê√£ th√™m **{song_data['title']}** v√†o danh s√°ch y√™u th√≠ch!")
            else:
                await ctx.send("‚ùå B√†i h√°t n√†y ƒë√£ c√≥ trong danh s√°ch y√™u th√≠ch!")
                
        elif action == "list":
            favorites = queue.get_playlist(user_id, "Favorites")
            if not favorites:
                await ctx.send("üíî B·∫°n ch∆∞a c√≥ b√†i h√°t y√™u th√≠ch n√†o!")
                return
            
            embed = discord.Embed(title="‚ù§Ô∏è B√†i h√°t y√™u th√≠ch", color=discord.Color.red())
            for i, song in enumerate(favorites[:10], 1):
                duration = song.get('duration', 0)
                duration_str = f"{duration//60}:{duration%60:02d}" if duration else "N/A"
                embed.add_field(
                    name=f"{i}. {song['title'][:50]}",
                    value=f"‚è±Ô∏è {duration_str}",
                    inline=False
                )
            
            if len(favorites) > 10:
                embed.add_field(name="...", value=f"V√† {len(favorites)-10} b√†i kh√°c", inline=False)
            
            embed.set_footer(text=f"T·ªïng c·ªông: {len(favorites)} b√†i h√°t")
            await ctx.send(embed=embed)
            
        elif action == "play":
            favorites = queue.get_playlist(user_id, "Favorites")
            if not favorites:
                await ctx.send("üíî B·∫°n ch∆∞a c√≥ b√†i h√°t y√™u th√≠ch n√†o!")
                return
            
            # Load favorites v√†o queue
            current_queue = self.get_queue(ctx.guild.id)
            current_queue.clear()
            
            for song_data in favorites:
                current_queue.add(song_data)
            
            await ctx.send(f"‚ù§Ô∏è ƒê√£ load {len(favorites)} b√†i h√°t y√™u th√≠ch v√†o queue!")
        else:
            embed = discord.Embed(title="‚ù§Ô∏è Favorite Commands", color=discord.Color.red())
            embed.add_field(name="!favorite add", value="Th√™m b√†i ƒëang ph√°t v√†o y√™u th√≠ch", inline=False)
            embed.add_field(name="!favorite list", value="Hi·ªÉn th·ªã danh s√°ch y√™u th√≠ch", inline=False)
            embed.add_field(name="!favorite play", value="Ph√°t t·∫•t c·∫£ b√†i y√™u th√≠ch", inline=False)
            await ctx.send(embed=embed)

    # Helper methods for menu system interactions
    async def play_command(self, interaction, query):
        """Helper method for play command via interaction"""
        try:
            await interaction.response.defer()
        except:
            # Interaction ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω r·ªìi
            pass
        
        if not query.strip():
            try:
                await interaction.followup.send("‚ùå Vui l√≤ng nh·∫≠p t√™n b√†i h√°t ho·∫∑c URL!", ephemeral=True)
            except:
                pass
            return
        
        # Ki·ªÉm tra voice channel
        if not interaction.user.voice:
            try:
                await interaction.followup.send("‚ùå B·∫°n c·∫ßn v√†o voice channel tr∆∞·ªõc!", ephemeral=True)
            except:
                pass
            return
        
        voice_channel = interaction.user.voice.channel
        
        try:
            # ƒê·∫£m b·∫£o bot k·∫øt n·ªëi voice channel
            if not interaction.guild.voice_client:
                await voice_channel.connect()
                connection_msg = f"üîó ƒê√£ k·∫øt n·ªëi t·ªõi **{voice_channel.name}**"
            elif interaction.guild.voice_client.channel != voice_channel:
                await interaction.guild.voice_client.move_to(voice_channel)
                connection_msg = f"üîÑ ƒê√£ chuy·ªÉn t·ªõi **{voice_channel.name}**"
            else:
                connection_msg = None
        except Exception as e:
            try:
                await interaction.followup.send(f"‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi voice channel: {e}", ephemeral=True)
            except:
                pass
            return
        
        # G·ª≠i th√¥ng b√°o t√¨m ki·∫øm
        try:
            search_msg = await interaction.followup.send(f"üîç ƒêang t√¨m ki·∫øm: **{query}**...")
        except:
            search_msg = None
        
        try:
            url_pattern = re.compile(r'https?://')
            if url_pattern.match(query):
                loop = self.bot.loop or asyncio.get_event_loop()
                data = await loop.run_in_executor(None, lambda: ytdl.extract_info(query, download=False))
                if 'entries' in data:
                    data = data['entries'][0]
            else:
                data = await YTDLSource.search_youtube(query)
            if not data:
                if search_msg:
                    await search_msg.edit(content="‚ùå Kh√¥ng t√¨m th·∫•y b√†i h√°t tr√™n YouTube!")
                return
            queue = self.get_queue(interaction.guild.id)
            voice_client = interaction.guild.voice_client
            if not voice_client.is_playing() and not voice_client.is_paused():
                try:
                    player = await self.create_player(data, interaction.guild.id)
                    queue.current = data
                    def after_playing(error):
                        if error:
                            print(f"Player error: {error}")
                        if voice_client and voice_client.is_connected():
                            fake_ctx = self.create_fake_context(interaction)
                            coro = self.play_next(fake_ctx)
                            asyncio.run_coroutine_threadsafe(coro, self.bot.loop)
                    voice_client.play(player, after=after_playing)
                    
                    # Detect platform cho slash command
                    platform_info = "üé¨ YouTube"
                    
                    embed = discord.Embed(title="üéµ ƒêang ph√°t", description=f"**{player.title}**", color=discord.Color.green())
                    embed.add_field(name="N·ªÅn t·∫£ng", value=platform_info, inline=True)
                    if player.uploader:
                        embed.add_field(name="K√™nh", value=player.uploader, inline=True)
                    if data.get('duration'):
                        embed.add_field(name="Th·ªùi l∆∞·ª£ng", value=self.format_duration(data['duration']), inline=True)
                    if player.thumbnail:
                        embed.set_thumbnail(url=player.thumbnail)
                    if connection_msg:
                        embed.add_field(name="Tr·∫°ng th√°i", value=connection_msg, inline=False)
                    if search_msg:
                        await search_msg.edit(content="", embed=embed)
                    else:
                        await interaction.followup.send(embed=embed)
                    try:
                        await asyncio.sleep(1)
                        control_embed = discord.Embed(title="üéõÔ∏è B·ªô ƒëi·ªÅu khi·ªÉn nh·∫°c", description=f"**{player.title}**", color=discord.Color.green())
                        view = MusicControlView(self.bot, interaction.guild.id)
                        control_message = await interaction.followup.send(embed=control_embed, view=view)
                        
                        # ƒêƒÉng k√Ω message ƒë·ªÉ auto cleanup sau 10 ph√∫t
                        auto_cleanup_cog = self.bot.get_cog('AutoCleanupCog')
                        if auto_cleanup_cog:
                            auto_cleanup_cog.add_message_for_cleanup(control_message, delete_after=600)
                    except:
                        pass
                except Exception as e:
                    if search_msg:
                        await search_msg.edit(content=f"‚ùå L·ªói khi ph√°t nh·∫°c: {e}")
                    else:
                        await interaction.followup.send(f"‚ùå L·ªói khi ph√°t nh·∫°c: {e}")
            else:
                queue.add(data)
                
                # Detect platform cho queue message
                platform_info = "üé¨ YouTube"
                
                embed = discord.Embed(title="üìù ƒê√£ th√™m v√†o queue", description=f"**{data['title']}**", color=discord.Color.blurple())
                embed.add_field(name="N·ªÅn t·∫£ng", value=platform_info, inline=True)
                embed.add_field(name="V·ªã tr√≠", value=f"#{len(queue.queue)}", inline=True)
                if data.get('uploader'):
                    embed.add_field(name="K√™nh", value=data['uploader'], inline=True)
                if data.get('duration'):
                    embed.add_field(name="Th·ªùi l∆∞·ª£ng", value=self.format_duration(data['duration']), inline=True)
                if data.get('thumbnail'):
                    embed.set_thumbnail(url=data['thumbnail'])
                if search_msg:
                    await search_msg.edit(content="", embed=embed)
                    # ƒêƒÉng k√Ω search message ƒë·ªÉ auto cleanup
                    auto_cleanup_cog = self.bot.get_cog('AutoCleanupCog')
                    if auto_cleanup_cog:
                        auto_cleanup_cog.add_message_for_cleanup(search_msg, delete_after=300)  # 5 ph√∫t cho message th√™m v√†o queue
                else:
                    queue_message = await interaction.followup.send(embed=embed)
                    # ƒêƒÉng k√Ω message ƒë·ªÉ auto cleanup
                    auto_cleanup_cog = self.bot.get_cog('AutoCleanupCog')
                    if auto_cleanup_cog:
                        auto_cleanup_cog.add_message_for_cleanup(queue_message, delete_after=300)
        except Exception as e:
            if search_msg:
                await search_msg.edit(content=f"‚ùå L·ªói: {e}")
            else:
                try:
                    await interaction.followup.send(f"‚ùå L·ªói: {e}")
                except:
                    pass

    @commands.command(name='hqaudio')
    async def hq_audio(self, ctx, mode: str = None):
        """B·∫≠t/t·∫Øt t·ªëi ∆∞u √¢m thanh (normalize). D√πng: !hqaudio on/off"""
        if mode is None:
            cfg = self.hq_settings.get(ctx.guild.id, {'normalize': False})
            await ctx.send(f"üéß HQ Normalize: {'ON' if cfg.get('normalize') else 'OFF'}")
            return
        mode = mode.lower()
        if mode in ("on", "normalize"):
            self.hq_settings.setdefault(ctx.guild.id, {})['normalize'] = True
            await ctx.send("üéß ƒê√£ b·∫≠t loudness normalization!")
        elif mode in ("off", "disable"):
            self.hq_settings.setdefault(ctx.guild.id, {})['normalize'] = False
            await ctx.send("üéß ƒê√£ t·∫Øt loudness normalization!")
        else:
            await ctx.send("‚ùå Tham s·ªë kh√¥ng h·ª£p l·ªá! D√πng: on/off")

    @app_commands.command(name="hqaudio", description="B·∫≠t/t·∫Øt t·ªëi ∆∞u √¢m thanh (normalize)")
    @app_commands.describe(mode="on/off")
    async def slash_hqaudio(self, interaction: discord.Interaction, mode: str = ""):
        mode = mode.lower()
        if mode in ("on", "normalize"):
            self.hq_settings.setdefault(interaction.guild.id, {})['normalize'] = True
            await interaction.response.send_message("üéß ƒê√£ b·∫≠t loudness normalization!", ephemeral=True)
        elif mode in ("off", "disable"):
            self.hq_settings.setdefault(interaction.guild.id, {})['normalize'] = False
            await interaction.response.send_message("üéß ƒê√£ t·∫Øt loudness normalization!", ephemeral=True)
        else:
            cfg = self.hq_settings.get(interaction.guild.id, {'normalize': False})
            await interaction.response.send_message(f"üéß HQ Normalize: {'ON' if cfg.get('normalize') else 'OFF'} (d√πng /hqaudio on|off)", ephemeral=True)

    @commands.command(name='autodj')
    async def autodj_command(self, ctx, mode: str = None):
        """B·∫≠t/t·∫Øt Auto DJ 24/7 - ph√°t nh·∫°c li√™n t·ª•c khi h·∫øt queue"""
        queue = self.get_queue(ctx.guild.id)
        
        if mode is None:
            status = "üü¢ B·∫¨T" if queue.auto_dj_24_7 else "üî¥ T·∫ÆT" 
            embed = discord.Embed(
                title="üéµ Auto DJ 24/7",
                description=f"**Tr·∫°ng th√°i:** {status}",
                color=discord.Color.green() if queue.auto_dj_24_7 else discord.Color.red()
            )
            embed.add_field(
                name="‚ÑπÔ∏è Th√¥ng tin",
                value="Auto DJ s·∫Ω t·ª± ƒë·ªông ph√°t nh·∫°c li√™n quan khi h·∫øt b√†i trong queue",
                inline=False
            )
            embed.add_field(
                name="üìù C√°ch d√πng",
                value="`!autodj on` - B·∫≠t\n`!autodj off` - T·∫Øt",
                inline=False
            )
            await ctx.send(embed=embed)
            return
        
        mode = mode.lower()
        if mode in ["on", "enable", "start", "1"]:
            queue.auto_dj_24_7 = True
            embed = discord.Embed(
                title="üéµ Auto DJ 24/7 - ƒê√£ B·∫¨T",
                description="Bot s·∫Ω t·ª± ƒë·ªông ph√°t nh·∫°c li√™n t·ª•c khi h·∫øt queue!",
                color=discord.Color.green()
            )
            embed.add_field(
                name="üé∂ T√≠nh nƒÉng",
                value="‚Ä¢ Ph√°t nh·∫°c li√™n quan ƒë·∫øn b√†i v·ª´a nghe\n‚Ä¢ T·ª± ƒë·ªông t√¨m nh·∫°c trending\n‚Ä¢ Kh√¥ng bao gi·ªù im l·∫∑ng\n‚Ä¢ Th√¥ng minh d·ª±a tr√™n l·ªãch s·ª≠",
                inline=False
            )
            embed.set_footer(text="G√µ !autodj off ƒë·ªÉ t·∫Øt")
            await ctx.send(embed=embed)
            
        elif mode in ["off", "disable", "stop", "0"]:
            queue.auto_dj_24_7 = False
            embed = discord.Embed(
                title="üéµ Auto DJ 24/7 - ƒê√£ T·∫ÆT",
                description="Bot s·∫Ω d·ª´ng khi h·∫øt nh·∫°c trong queue",
                color=discord.Color.red()
            )
            await ctx.send(embed=embed)
        else:
            await ctx.send("‚ùå Tham s·ªë kh√¥ng h·ª£p l·ªá! D√πng: `!autodj on` ho·∫∑c `!autodj off`")

    @app_commands.command(name="autodj", description="B·∫≠t/t·∫Øt Auto DJ 24/7 - ph√°t nh·∫°c li√™n t·ª•c")
    @app_commands.describe(mode="on/off")
    @app_commands.choices(mode=[
        app_commands.Choice(name="B·∫≠t", value="on"),
        app_commands.Choice(name="T·∫Øt", value="off")
    ])
    async def slash_autodj(self, interaction: discord.Interaction, mode: str = ""):
        await interaction.response.defer()
        
        queue = self.get_queue(interaction.guild.id)
        
        if not mode:
            status = "üü¢ B·∫¨T" if queue.auto_dj_24_7 else "üî¥ T·∫ÆT"
            embed = discord.Embed(
                title="üéµ Auto DJ 24/7",
                description=f"**Tr·∫°ng th√°i:** {status}",
                color=discord.Color.green() if queue.auto_dj_24_7 else discord.Color.red()
            )
            embed.add_field(
                name="‚ÑπÔ∏è Th√¥ng tin", 
                value="Auto DJ s·∫Ω t·ª± ƒë·ªông ph√°t nh·∫°c li√™n quan khi h·∫øt b√†i trong queue",
                inline=False
            )
            await interaction.followup.send(embed=embed)
            return
        
        mode = mode.lower()
        if mode == "on":
            queue.auto_dj_24_7 = True
            embed = discord.Embed(
                title="üéµ Auto DJ 24/7 - ƒê√£ B·∫¨T",
                description="Bot s·∫Ω t·ª± ƒë·ªông ph√°t nh·∫°c li√™n t·ª•c khi h·∫øt queue!",
                color=discord.Color.green()
            )
            embed.add_field(
                name="üé∂ T√≠nh nƒÉng",
                value="‚Ä¢ Ph√°t nh·∫°c li√™n quan ƒë·∫øn b√†i v·ª´a nghe\n‚Ä¢ T·ª± ƒë·ªông t√¨m nh·∫°c trending\n‚Ä¢ Kh√¥ng bao gi·ªù im l·∫∑ng\n‚Ä¢ Th√¥ng minh d·ª±a tr√™n l·ªãch s·ª≠",
                inline=False
            )
            embed.set_footer(text="D√πng /autodj off ƒë·ªÉ t·∫Øt")
            await interaction.followup.send(embed=embed)
            
        elif mode == "off":
            queue.auto_dj_24_7 = False
            embed = discord.Embed(
                title="üéµ Auto DJ 24/7 - ƒê√£ T·∫ÆT", 
                description="Bot s·∫Ω d·ª´ng khi h·∫øt nh·∫°c trong queue",
                color=discord.Color.red()
            )
            await interaction.followup.send(embed=embed)

async def setup(bot):
    await bot.add_cog(MusicCog(bot))