import discord # type: ignore
from discord.ext import commands # type: ignore
import random
import asyncio
from typing import Optional, Dict, List

class Games(commands.Cog):
    """üéØ Mini Games - C√°c tr√≤ ch∆°i t∆∞∆°ng t√°c vui nh·ªôn"""
    
    def __init__(self, bot):
        self.bot = bot
        self.active_games = {}  # Track active games per channel
        
        # Quiz questions database
        self.quiz_questions = [
            {
                "question": "Th·ªß ƒë√¥ c·ªßa Vi·ªát Nam l√† g√¨?",
                "options": ["A. H·ªì Ch√≠ Minh", "B. H√† N·ªôi", "C. ƒê√† N·∫µng", "D. C·∫ßn Th∆°"],
                "correct": "B",
                "explanation": "H√† N·ªôi l√† th·ªß ƒë√¥ c·ªßa Vi·ªát Nam t·ª´ nƒÉm 1010."
            },
            {
                "question": "H√†nh tinh n√†o g·∫ßn M·∫∑t Tr·ªùi nh·∫•t?",
                "options": ["A. Sao Kim", "B. Tr√°i ƒê·∫•t", "C. Sao Th·ªßy", "D. Sao H·ªèa"],
                "correct": "C",
                "explanation": "Sao Th·ªßy l√† h√†nh tinh g·∫ßn M·∫∑t Tr·ªùi nh·∫•t trong h·ªá M·∫∑t Tr·ªùi."
            },
            {
                "question": "Ai l√† t√°c gi·∫£ c·ªßa t√°c ph·∫©m 'Truy·ªán Ki·ªÅu'?",
                "options": ["A. Nguy·ªÖn Du", "B. H·ªì Xu√¢n H∆∞∆°ng", "C. Nguy·ªÖn Khuy·∫øn", "D. T√∫ X∆∞∆°ng"],
                "correct": "A",
                "explanation": "Nguy·ªÖn Du l√† t√°c gi·∫£ c·ªßa 'Truy·ªán Ki·ªÅu', t√°c ph·∫©m vƒ© ƒë·∫°i c·ªßa vƒÉn h·ªçc Vi·ªát Nam."
            },
            {
                "question": "2 + 2 x 3 = ?",
                "options": ["A. 12", "B. 8", "C. 10", "D. 6"],
                "correct": "B",
                "explanation": "Theo th·ª© t·ª± ph√©p t√≠nh: 2 + (2 x 3) = 2 + 6 = 8"
            },
            {
                "question": "Ng√¥n ng·ªØ l·∫≠p tr√¨nh n√†o ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ t·∫°o ra bot Discord n√†y?",
                "options": ["A. Java", "B. JavaScript", "C. Python", "D. C++"],
                "correct": "C",
                "explanation": "Bot n√†y ƒë∆∞·ª£c vi·∫øt b·∫±ng Python v·ªõi th∆∞ vi·ªán discord.py"
            }
        ]
    
    @commands.command(name='tracnghiem', aliases=['quiz'])
    @commands.cooldown(1, 30, commands.BucketType.channel)
    async def quiz_game(self, ctx):
        """T·∫°o c√¢u h·ªèi tr·∫Øc nghi·ªám vui"""
        if ctx.channel.id in self.active_games:
            embed = discord.Embed(
                title="‚ö†Ô∏è Game ƒëang di·ªÖn ra",
                description="C√≥ m·ªôt game kh√°c ƒëang di·ªÖn ra trong k√™nh n√†y!",
                color=0xFFFF00
            )
            await ctx.send(embed=embed)
            return
        
        # Mark channel as having active game
        self.active_games[ctx.channel.id] = "quiz"
        
        try:
            question_data = random.choice(self.quiz_questions)
            
            embed = discord.Embed(
                title="üß† C√¢u h·ªèi tr·∫Øc nghi·ªám",
                description=question_data["question"],
                color=0x7289DA
            )
            
            options_text = "\n".join(question_data["options"])
            embed.add_field(name="üìù L·ª±a ch·ªçn", value=options_text, inline=False)
            embed.add_field(name="‚è∞ Th·ªùi gian", value="30 gi√¢y ƒë·ªÉ tr·∫£ l·ªùi", inline=False)
            embed.set_footer(text="G√µ A, B, C, ho·∫∑c D ƒë·ªÉ tr·∫£ l·ªùi!")
            
            await ctx.send(embed=embed)
            
            def check(message):
                return (message.channel == ctx.channel and 
                       message.content.upper() in ['A', 'B', 'C', 'D'] and
                       not message.author.bot)
            
            try:
                # Wait for answer
                answer_msg = await self.bot.wait_for('message', timeout=30.0, check=check)
                
                if answer_msg.content.upper() == question_data["correct"]:
                    # Correct answer
                    embed = discord.Embed(
                        title="üéâ Ch√≠nh x√°c!",
                        description=f"{answer_msg.author.mention} ƒë√£ tr·∫£ l·ªùi ƒë√∫ng!",
                        color=0x00FF00
                    )
                    embed.add_field(name="üí° Gi·∫£i th√≠ch", value=question_data["explanation"], inline=False)
                    
                else:
                    # Wrong answer
                    embed = discord.Embed(
                        title="‚ùå Sai r·ªìi!",
                        description=f"ƒê√°p √°n ƒë√∫ng l√† **{question_data['correct']}**",
                        color=0xFF0000
                    )
                    embed.add_field(name="üí° Gi·∫£i th√≠ch", value=question_data["explanation"], inline=False)
                
                await ctx.send(embed=embed)
                
            except asyncio.TimeoutError:
                embed = discord.Embed(
                    title="‚è∞ H·∫øt th·ªùi gian!",
                    description=f"ƒê√°p √°n ƒë√∫ng l√† **{question_data['correct']}**",
                    color=0xFF0000
                )
                embed.add_field(name="üí° Gi·∫£i th√≠ch", value=question_data["explanation"], inline=False)
                await ctx.send(embed=embed)
        
        finally:
            # Remove active game marker
            if ctx.channel.id in self.active_games:
                del self.active_games[ctx.channel.id]
    
    @commands.command(name='choinhanh', aliases=['quickgame'])
    @commands.cooldown(1, 45, commands.BucketType.channel)
    async def quick_game(self, ctx):
        """Tr√≤ ch∆°i tr·∫£ l·ªùi nhanh"""
        if ctx.channel.id in self.active_games:
            embed = discord.Embed(
                title="‚ö†Ô∏è Game ƒëang di·ªÖn ra",
                description="C√≥ m·ªôt game kh√°c ƒëang di·ªÖn ra trong k√™nh n√†y!",
                color=0xFFFF00
            )
            await ctx.send(embed=embed)
            return
        
        self.active_games[ctx.channel.id] = "quick"
        
        try:
            # Random quick questions
            quick_questions = [
                {"question": "M√†u g√¨ ƒë∆∞·ª£c t·∫°o b·ªüi ƒë·ªè + v√†ng?", "answer": ["cam", "orange", "m√†u cam"]},
                {"question": "Th·ªß ƒë√¥ c·ªßa Nh·∫≠t B·∫£n?", "answer": ["tokyo", "t√¥ky√¥", "tokyo"]},
                {"question": "7 x 8 = ?", "answer": ["56"]},
                {"question": "H√†nh tinh l·ªõn nh·∫•t h·ªá M·∫∑t Tr·ªùi?", "answer": ["sao m·ªôc", "jupiter", "m·ªôc tinh"]},
                {"question": "Ng√†nh h·ªçc v·ªÅ m√°y t√≠nh?", "answer": ["tin h·ªçc", "khoa h·ªçc m√°y t√≠nh", "cntt", "it"]},
                {"question": "Bi·ªÉu t∆∞·ª£ng h√≥a h·ªçc c·ªßa n∆∞·ªõc?", "answer": ["h2o", "H2O"]},
                {"question": "T√°c gi·∫£ Harry Potter?", "answer": ["j.k. rowling", "rowling", "jk rowling"]},
                {"question": "1000 + 500 = ?", "answer": ["1500"]},
                {"question": "Th·ªß ƒë√¥ c·ªßa Ph√°p?", "answer": ["paris", "pa ri", "pa-ri"]},
                {"question": "Con v·∫≠t n√†o bay ƒë∆∞·ª£c?", "answer": ["chim", "b∆∞·ªõm", "ong", "ru·ªìi", "chim c√°nh c·ª•t"]}
            ]
            
            question_data = random.choice(quick_questions)
            
            embed = discord.Embed(
                title="‚ö° Tr·∫£ l·ªùi nhanh!",
                description=question_data["question"],
                color=0xFFD700
            )
            embed.add_field(name="‚è∞ Th·ªùi gian", value="15 gi√¢y!", inline=False)
            embed.set_footer(text="Ai tr·∫£ l·ªùi ƒë√∫ng ƒë·∫ßu ti√™n s·∫Ω th·∫Øng!")
            
            await ctx.send(embed=embed)
            
            def check(message):
                return (message.channel == ctx.channel and 
                       not message.author.bot and
                       any(ans.lower() in message.content.lower() for ans in question_data["answer"]))
            
            try:
                winner_msg = await self.bot.wait_for('message', timeout=15.0, check=check)
                
                embed = discord.Embed(
                    title="üèÜ C√≥ ng∆∞·ªùi th·∫Øng!",
                    description=f"{winner_msg.author.mention} ƒë√£ tr·∫£ l·ªùi ƒë√∫ng ƒë·∫ßu ti√™n!",
                    color=0x00FF00
                )
                embed.add_field(name="‚úÖ ƒê√°p √°n", value=question_data["answer"][0].title(), inline=False)
                
                await ctx.send(embed=embed)
                
            except asyncio.TimeoutError:
                embed = discord.Embed(
                    title="‚è∞ H·∫øt th·ªùi gian!",
                    description="Kh√¥ng ai tr·∫£ l·ªùi ƒë√∫ng trong th·ªùi gian quy ƒë·ªãnh",
                    color=0xFF0000
                )
                embed.add_field(name="üí° ƒê√°p √°n", value=question_data["answer"][0].title(), inline=False)
                await ctx.send(embed=embed)
        
        finally:
            if ctx.channel.id in self.active_games:
                del self.active_games[ctx.channel.id]
    
    @commands.command(name='guessnumber', aliases=['doanso'])
    @commands.cooldown(1, 60, commands.BucketType.channel)
    async def guess_number(self, ctx, max_number: int = 100):
        """ƒêo√°n s·ªë t·ª´ 1 ƒë·∫øn max_number"""
        if ctx.channel.id in self.active_games:
            embed = discord.Embed(
                title="‚ö†Ô∏è Game ƒëang di·ªÖn ra",
                description="C√≥ m·ªôt game kh√°c ƒëang di·ªÖn ra trong k√™nh n√†y!",
                color=0xFFFF00
            )
            await ctx.send(embed=embed)
            return
        
        if max_number < 10 or max_number > 1000:
            embed = discord.Embed(
                title="‚ùå S·ªë kh√¥ng h·ª£p l·ªá",
                description="S·ªë t·ªëi ƒëa ph·∫£i t·ª´ 10 ƒë·∫øn 1000!",
                color=0xFF0000
            )
            await ctx.send(embed=embed)
            return
        
        self.active_games[ctx.channel.id] = "guess"
        
        try:
            secret_number = random.randint(1, max_number)
            attempts = 0
            max_attempts = min(10, max_number // 10 + 3)
            
            embed = discord.Embed(
                title="üî¢ ƒêo√°n s·ªë!",
                description=f"T√¥i ƒë√£ nghƒ© ra m·ªôt s·ªë t·ª´ 1 ƒë·∫øn {max_number}",
                color=0x7289DA
            )
            embed.add_field(name="üéØ M·ª•c ti√™u", value="ƒêo√°n ƒë√∫ng s·ªë t√¥i nghƒ©!", inline=False)
            embed.add_field(name="üî¢ C√°ch ch∆°i", value="G√µ m·ªôt s·ªë ƒë·ªÉ ƒëo√°n", inline=False)
            embed.add_field(name="‚è∞ Gi·ªõi h·∫°n", value=f"{max_attempts} l·∫ßn ƒëo√°n", inline=False)
            
            await ctx.send(embed=embed)
            
            while attempts < max_attempts:
                def check(message):
                    try:
                        number = int(message.content)
                        return (message.channel == ctx.channel and 
                               not message.author.bot and
                               1 <= number <= max_number)
                    except ValueError:
                        return False
                
                try:
                    guess_msg = await self.bot.wait_for('message', timeout=30.0, check=check)
                    guess = int(guess_msg.content)
                    attempts += 1
                    
                    if guess == secret_number:
                        # Winner!
                        embed = discord.Embed(
                            title="üéâ Ch√∫c m·ª´ng!",
                            description=f"{guess_msg.author.mention} ƒë√£ ƒëo√°n ƒë√∫ng s·ªë **{secret_number}**!",
                            color=0x00FF00
                        )
                        embed.add_field(name="üèÜ K·∫øt qu·∫£", value=f"ƒêo√°n ƒë√∫ng sau {attempts} l·∫ßn th·ª≠", inline=False)
                        
                        # Calculate XP based on attempts
                        await ctx.send(embed=embed)
                        return
                    
                    elif guess < secret_number:
                        hint = "üìà S·ªë c·∫ßn t√¨m l·ªõn h∆°n!"
                        color = 0xFFFF00
                    else:
                        hint = "üìâ S·ªë c·∫ßn t√¨m nh·ªè h∆°n!"
                        color = 0xFFFF00
                    
                    embed = discord.Embed(
                        title=f"L·∫ßn th·ª≠ {attempts}/{max_attempts}",
                        description=f"{guess_msg.author.mention}: **{guess}** - {hint}",
                        color=color
                    )
                    
                    if attempts < max_attempts:
                        embed.set_footer(text=f"C√≤n {max_attempts - attempts} l·∫ßn th·ª≠!")
                    
                    await ctx.send(embed=embed)
                    
                except asyncio.TimeoutError:
                    embed = discord.Embed(
                        title="‚è∞ H·∫øt th·ªùi gian!",
                        description=f"Kh√¥ng ai ƒëo√°n trong 30 gi√¢y. S·ªë c·∫ßn t√¨m l√† **{secret_number}**",
                        color=0xFF0000
                    )
                    await ctx.send(embed=embed)
                    return
            
            # Max attempts reached
            embed = discord.Embed(
                title="üí• Game Over!",
                description=f"ƒê√£ h·∫øt {max_attempts} l·∫ßn ƒëo√°n. S·ªë c·∫ßn t√¨m l√† **{secret_number}**",
                color=0xFF0000
            )
            await ctx.send(embed=embed)
        
        finally:
            if ctx.channel.id in self.active_games:
                del self.active_games[ctx.channel.id]
    
    @commands.command(name='rps', aliases=['keobuabao'])
    async def rock_paper_scissors(self, ctx, choice: str = None):
        """K√©o b√∫a bao v·ªõi bot"""
        if not choice:
            embed = discord.Embed(
                title="‚úÇÔ∏è K√©o B√∫a Bao",
                description=f"S·ª≠ d·ª•ng: `{self.bot.config['prefix']}rps <k√©o/b√∫a/bao>`\n"
                           f"Ho·∫∑c: `{self.bot.config['prefix']}rps <rock/paper/scissors>`",
                color=0x7289DA
            )
            await ctx.send(embed=embed)
            return
        
        # Normalize choice
        choice = choice.lower()
        choice_map = {
            'k√©o': 'scissors', 'keo': 'scissors', 'scissors': 'scissors',
            'b√∫a': 'rock', 'bua': 'rock', 'rock': 'rock', 'ƒë√°': 'rock', 'da': 'rock',
            'bao': 'paper', 'paper': 'paper', 'gi·∫•y': 'paper', 'giay': 'paper'
        }
        
        if choice not in choice_map:
            embed = discord.Embed(
                title="‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá",
                description="Ch·ªçn: k√©o, b√∫a, ho·∫∑c bao",
                color=0xFF0000
            )
            await ctx.send(embed=embed)
            return
        
        user_choice = choice_map[choice]
        bot_choice = random.choice(['rock', 'paper', 'scissors'])
        
        # Determine winner
        if user_choice == bot_choice:
            result = "H√≤a!"
            color = 0xFFFF00
        elif (user_choice == 'rock' and bot_choice == 'scissors') or \
             (user_choice == 'paper' and bot_choice == 'rock') or \
             (user_choice == 'scissors' and bot_choice == 'paper'):
            result = "B·∫°n th·∫Øng!"
            color = 0x00FF00
        else:
            result = "Bot th·∫Øng!"
            color = 0xFF0000
        
        # Emoji mapping
        emoji_map = {
            'rock': 'ü™®',
            'paper': 'üìÑ', 
            'scissors': '‚úÇÔ∏è'
        }
        
        embed = discord.Embed(
            title="‚úÇÔ∏è K√©o B√∫a Bao",
            description=f"**{result}**",
            color=color
        )
        embed.add_field(name="B·∫°n ch·ªçn", value=f"{emoji_map[user_choice]} {user_choice.title()}", inline=True)
        embed.add_field(name="Bot ch·ªçn", value=f"{emoji_map[bot_choice]} {bot_choice.title()}", inline=True)
        
        await ctx.send(embed=embed)
    
    @commands.command(name='trivia', aliases=['hoidap'])
    async def trivia_question(self, ctx):
        """C√¢u h·ªèi t·ªïng h·ª£p ki·∫øn th·ª©c"""
        # Use existing quiz system but single question
        question_data = random.choice(self.quiz_questions)
        
        embed = discord.Embed(
            title="ü§î C√¢u h·ªèi Trivia",
            description=question_data["question"],
            color=0x7289DA
        )
        
        # Shuffle options
        options = question_data["options"].copy()
        random.shuffle(options)
        
        options_text = "\n".join(options)
        embed.add_field(name="üìù L·ª±a ch·ªçn", value=options_text, inline=False)
        embed.set_footer(text="React v·ªõi üá¶ üáß üá® üá© ƒë·ªÉ tr·∫£ l·ªùi!")
        
        message = await ctx.send(embed=embed)
        
        # Add reaction options
        reactions = ['üá¶', 'üáß', 'üá®', 'üá©']
        for reaction in reactions:
            await message.add_reaction(reaction)
        
        # The rest would require reaction handling which is more complex
        # For now, just show the question

    # Helper methods for menu system interactions
    async def rps_command(self, interaction, user_choice):
        """Helper method for rock paper scissors via interaction"""
        await interaction.response.defer()
        
        choices = ['rock', 'paper', 'scissors']
        choice_mapping = {
            'rock': 'rock', 'b√∫a': 'rock', 'ƒë√°': 'rock',
            'paper': 'paper', 'bao': 'paper', 'gi·∫•y': 'paper', 
            'scissors': 'scissors', 'k√©o': 'scissors'
        }
        
        # Normalize user choice
        user_choice = user_choice.lower().strip()
        if user_choice in choice_mapping:
            user_choice = choice_mapping[user_choice]
        
        if user_choice not in choices:
            await interaction.followup.send("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá! Ch·ªçn: rock/b√∫a, paper/bao, scissors/k√©o", ephemeral=True)
            return
        
        bot_choice = random.choice(choices)
        
        # Determine winner
        if user_choice == bot_choice:
            result = "ü§ù H√≤a!"
            color = 0xffff00
            xp_bonus = 1
        elif (
            (user_choice == 'rock' and bot_choice == 'scissors') or
            (user_choice == 'paper' and bot_choice == 'rock') or
            (user_choice == 'scissors' and bot_choice == 'paper')
        ):
            result = "üéâ B·∫°n th·∫Øng!"
            color = 0x00ff00
            xp_bonus = 3
        else:
            result = "üò¢ Bot th·∫Øng!"
            color = 0xff0000
            xp_bonus = 1
        
        # Emoji mapping
        emoji_map = {
            'rock': '‚úä',
            'paper': '‚úã', 
            'scissors': '‚úåÔ∏è'
        }
        
        embed = discord.Embed(
            title="‚úÇÔ∏è K√©o B√∫a Bao",
            description=f"**{result}**",
            color=color
        )
        embed.add_field(name="B·∫°n ch·ªçn", value=f"{emoji_map[user_choice]} {user_choice.title()}", inline=True)
        embed.add_field(name="Bot ch·ªçn", value=f"{emoji_map[bot_choice]} {bot_choice.title()}", inline=True)
        
        if xp_bonus > 0:
            try:
                await self.bot.db.add_xp(interaction.user.id, interaction.guild.id, xp_bonus)
                embed.add_field(name="üéÅ XP", value=f"+{xp_bonus}", inline=False)
            except:
                pass  # XP system might not be available
        
        await interaction.followup.send(embed=embed)

    async def eightball_command(self, interaction, question):
        """Helper method for 8ball command via interaction"""
        await interaction.response.defer()
        
        if not question.strip():
            await interaction.followup.send("‚ùå Vui l√≤ng nh·∫≠p m·ªôt c√¢u h·ªèi!", ephemeral=True)
            return
        
        responses = [
            "üéØ Ch·∫Øc ch·∫Øn!", "‚úÖ C√≥!", "üåü Ho√†n to√†n ƒë√∫ng!", 
            "üíØ Kh√¥ng nghi ng·ªù g√¨!", "üëç C√≥ th·ªÉ tin t∆∞·ªüng!",
            "ü§î C√≥ l·∫Ω...", "‚öñÔ∏è Kh√≥ n√≥i...", "üé≤ H·ªèi l·∫°i sau!",
            "üå´Ô∏è Kh√¥ng r√µ...", "‚è≥ Ch·ªù xem...",
            "‚ùå Kh√¥ng!", "üëé Kh√¥ng ch·∫Øc!", "üö´ T√¥i kh√¥ng nghƒ© v·∫≠y!",
            "‚õî Ch·∫Øc ch·∫Øn kh√¥ng!", "üôÖ‚Äç‚ôÇÔ∏è ƒê·ª´ng m∆°!"
        ]
        
        response = random.choice(responses)
        
        embed = discord.Embed(
            title="üé± Qu·∫£ c·∫ßu th·∫ßn tr·∫£ l·ªùi",
            color=0x8B00FF
        )
        embed.add_field(name="‚ùì C√¢u h·ªèi", value=question, inline=False)
        embed.add_field(name="üé± Tr·∫£ l·ªùi", value=response, inline=False)
        embed.set_footer(text="üîÆ Ch·ªâ mang t√≠nh gi·∫£i tr√≠!")
        
        await interaction.followup.send(embed=embed)


async def setup(bot):
    await bot.add_cog(Games(bot))
